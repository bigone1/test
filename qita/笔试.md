#### [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

![Error](https://github.com/bigone1/test/blob/master/Screenshots/12.png)

```c++
int numTrees(int n) {
        vector<int> vec(n + 1, 0);
        vec[0] = 1;
        vec[1] = 1;
        for(int i=2;i<=n;++i)
            for (int j = 1; j <= i; ++j) {
                vec[i] += vec[i - j] * vec[j - 1];
            }
        return vec[n];
    }
```

#### 二叉树前序遍历-迭代法

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> out;
        if(root==NULL)
            return out;
        TreeNode* p;
        stack<TreeNode*> s;
        s.push(root);
        while(s.size()){
            p=s.top();
            out.push_back(p->val);
            s.pop();
            if(p->right)
                s.push(p->right);
            if(p->left)
                s.push(p->left);
        }
        return out;
    }
};
```

#### 二叉树中序遍历-迭代法

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> out;
        if(root==NULL)
            return out;
        stack<TreeNode*> s;
        TreeNode *p=root;
        while(s.size()>0 || p!=NULL){
            while(p!=NULL){
                s.push(p);
                p=p->left;
            }
            if(s.size()>0){
                p=s.top();
                out.push_back(p->val);
                s.pop();
                p=p->right;
            }
        }
        return out;
    }
};
```

#### 二叉树后序遍历-迭代法

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> out;
        if(root==NULL)
            return out;
        TreeNode* p;
        stack<TreeNode*> s;
        s.push(root);
        while(s.size()>0){
            p=s.top();
            s.pop();
            out.push_back(p->val);
            if(p->left)
                s.push(p->left);
            if(p->right)
                s.push(p->right);
        }
        reverse(out.begin(),out.end());
        return out;
    }
};
```

#### 二叉树层序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> out;
        if(root==NULL)
            return out;
        queue<TreeNode*> q;   
        q.push(root);
        while(!q.empty()){
            vector<int> tmp;
            size_t len=q.size();
            for(size_t i=0;i<len;++i){
                TreeNode* p=q.front();
                tmp.push_back(p->val);
                q.pop();
                if(p->left)
                    q.push(p->left);
                if(p->right)
                    q.push(p->right);
            }
            out.push_back(tmp);
        }
        return out;
    }
};
```

#### 设计循环队列

```c++
class MyCircularQueue {
private:
    vector<int> data;
    int head;
    int tail;
    int size;
public:
    /** Initialize your data structure here. Set the size of the queue to be k. */
    MyCircularQueue(int k) {
        data.resize(k);
        head = -1;
        tail = -1;
        size = k;
    }
    
    /** Insert an element into the circular queue. Return true if the operation is successful. */
    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        if (isEmpty()) {
            head = 0;
        }
        tail = (tail + 1) % size;
        data[tail] = value;
        return true;
    }
    
    /** Delete an element from the circular queue. Return true if the operation is successful. */
    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        if (head == tail) {
            head = -1;
            tail = -1;
            return true;
        }
        head = (head + 1) % size;
        return true;
    }
    
    /** Get the front item from the queue. */
    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[head];
    }
    
    /** Get the last item from the queue. */
    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[tail];
    }
    
    /** Checks whether the circular queue is empty or not. */
    bool isEmpty() {
        return head == -1;
    }
    
    /** Checks whether the circular queue is full or not. */
    bool isFull() {
        return ((tail + 1) % size) == head;
    }
};

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * bool param_1 = obj.enQueue(value);
 * bool param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * bool param_5 = obj.isEmpty();
 * bool param_6 = obj.isFull();
 */
```



#### [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

示例 2：

输入: "cbbd"
输出: "bb"

```c++
int z(int Left, int Right,string s) {
        int L = Left;
        int R = Right;
        while (L >= 0 && R < s.length() && s[L] == s[R]) {
            L--;
            R++;
        }
        return R - L -1;
    }
    string longestPalindrome(string s) {
        if (s.size() == 0 || s.size() == 1)
		return s;
        int len = s.size();
        int start = 0;
        int end = 0;
        int m = 0;
        for (int i = 0; i < len; ++i) {
            int len1 = z(i, i, s);
            int len2 = z(i, i + 1, s);
            m = max(max(len1, len2), m);
            if (m > end - start + 1)
            {
                start = i - (m - 1) / 2;
                end = i + m / 2;
            }
        }
        return s.substr(start, m);
    }
```

#### [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

    你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

```c++
int maxProfit(vector<int>& prices) {
        if (prices.empty())
                return 0;
        int len = prices.size();
        vector<vector<int>> vec(len+1, vector<int>(2));
        vec[0][0] = 0; vec[0][1] = INT_MIN;
        vec[1][0] = 0; vec[1][1] = -prices[0];
        for (int i = 2; i < len + 1; ++i) {
            vec[i][0] = max(vec[i - 1][0], vec[i - 1][1] + prices[i - 1]);
            vec[i][1] = max(vec[i - 1][1], vec[i - 2][0] - prices[i - 1]);
        }
        return vec[len][0];
    }
```

#### [四数之和](https://leetcode-cn.com/problems/4sum/)

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

答案中不可以包含重复的四元组。

示例：

给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

```c++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
	vector<vector<int>> out;
	size_t len = nums.size();
	if (len < 4)
		return out;
	sort(nums.begin(), nums.end());
	for (size_t i = 0; i < len - 3; ++i) {
		if (nums[i] > 0 && target <= 0)
			break;
		if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)
			break;
		if (nums[i] + nums[len - 3] + nums[len - 2] + nums[len - 1] < target)
			continue;
		if (i > 0 && nums[i] == nums[i - 1])
			continue;
		for (size_t j = i + 1; j < len - 2; ++j) {
			if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target)
				break;
			if (nums[i] + nums[j] + nums[len - 2] + nums[len - 1] < target)
				continue;
			if (j > i + 1 && nums[j] == nums[j - 1])
				continue;
			size_t start = j + 1, end = len - 1;
			while (start < end) {
				int sum = nums[i] + nums[j] + nums[start] + nums[end];
				if (sum < target)
					start++;
				else if (sum > target)
					end--;
				else {
					out.push_back({ nums[i],nums[j],nums[start],nums[end] });
					int laststart = start, lastend = end;
					while (start < end && nums[start] == nums[laststart])
						start++;
					while (start < end && nums[end] == nums[lastend])
						end--;
				}
			}
		}
	}
	return out;
}
```

#### 删数

有一个数组a[N]顺序存放0~N-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0->1->2(删除)->3->4->5(删除)->6->7->0(删除),如此循环直到最后一个数被删除。

##### **输入描述:**

```
每组数据为一行一个整数n(小于等于1000)，为数组成员数,如果大于1000，则对a[999]进行计算。
```

##### **输出描述:**

```
一行输出最后一个被删掉的数的原始下标位置。
```

##### **输入例子1:**

```
8
```

##### **输出例子1:**

```
6
```

```c++
#include <iostream>
#include<queue>
using namespace std;
int main()
{
	int N;
	while (cin >> N) {
		queue<int> q;
		for (int i = 0; i < N; ++i)
			q.push(i);
		int count = 0;
		while (q.size() != 1)
		{
			if (count != 2)
			{
				int a = q.front();
				q.push(a);
				q.pop();
				count++;
			}
			if (count == 2) {
				q.pop();
				count = 0;
			}
		}
		cout << q.front() << endl;
	}
	return 0;
}
```

#### 字符集合

输入一个字符串，求出该字符串包含的字符集合

##### **输入描述:**

```
每组数据输入一个字符串，字符串最大长度为100，且只包含字母，不可能为空串，区分大小写。
```

##### **输出描述:**

```
每组数据一行，按字符串原有的字符顺序，输出字符集合，即重复出现并靠后的字母不输出。
```

##### **输入例子1:**

```
abcqweracb
```

##### **输出例子1:**

```
abcqwer
```

```c++
#include<iostream>
#include<string>
#include<set>
using namespace std;

int main() {
	string s;
	while (cin >> s) {
		set<char> se;
		string out="";
		for (size_t i = 0; i < s.size(); ++i)
		{
			if (se.find(s[i]) == se.end())
				out = out + s[i];
			se.insert(s[i]);	
		}
		cout << out << endl;
	}
}
```

  #### 汽水瓶

有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？  

##### **输入描述:**

```
输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1<=n<=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。
```

##### **输出描述:**

```
对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。
```

##### **输入例子1:**

```
3
10
81
0
```

##### **输出例子1:**

```
1
5
40
```

```c++
#include<iostream>
using namespace std;

int main() {
	int N;
	while (cin >> N && N != 0) {
		int shui = 0;
		while (N != 1) {
			int shang = N / 3;
			int yu = N % 3;
			shui = shui + shang;
			N = shang + yu;
			if (N == 2)
				N = N + 1;
		}
		cout << shui << endl;
	}
	return 0;
}
```

# 明明的随机数

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 
 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 

  样例输入解释： 

  样例有两组测试 

  第一组是3个数字，分别是：2，2，1。 

  第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。

##### **输入描述:**

```
输入多行，先输入随机整数的个数，再输入相应个数的整数
```

##### **输出描述:**

```
返回多行，处理后的结果
```

##### **输入例子1:**

```
3
2
2
1
11
10
20
40
32
67
40
20
89
300
400
15
```

##### **输出例子1:**

```
1
2
10
15
20
32
40
67
89
300
400
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	int N,n;
	while (cin >> N) {
		vector<int> vec;
		for (int i = 0; i < N; ++i) {
			cin >> n;
			vec.push_back(n);
		}
		sort(vec.begin(), vec.end());
		vector<int>::iterator it = unique(vec.begin(), vec.end());
		for (vector<int>::iterator i = vec.begin(); i != it; ++i)
			cout << *i << endl;
	}
	return 0;
}
```

# 进制转换

写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）  

##### **输入描述:**

```
输入一个十六进制的数值字符串。
```

##### **输出描述:**

```
输出该数值的十进制字符串。
```

##### **输入例子1:**

```
0xA
```

##### **输出例子1:**

```
10
```

```c++
#include<iostream>
#include<string>
#include<map>
#include<cmath>
using namespace std;

int main() {
	string s;
	map<char, int> m{ {'0',0},{'1',1},{'2',2},{'3',3},{'4',4},{'5',5},{'6',6},{'7',7},{'8',8},{'9',9},{'A',10},{'B',11},{'C',12},{'D',13},{'E',14},{'F',15}};
	while (getline(cin, s)) {
		int out = 0;
		size_t t = s.size()-3;
		for (size_t i = 2; i < s.size(); ++i)
		{
			out = out + m[s[i]] * pow(16,t);
			t = t - 1;
		}
		cout << out << endl;
	}
}
```

# 归并排序

```c++
#include<iostream>
#include<vector>
using namespace std;

void merge(int arr[], int left, int mid, int right)
{
	std::vector<int> *result = new std::vector<int>();
	int l = left;
	int m = mid;
	while (l <= mid - 1 && m <= right)
	{
		if (arr[l] <= arr[m]) {
			result->push_back(arr[l++]);
		}
		else {
			result->push_back(arr[m++]);
		}
	}
	while (l <= mid - 1) {
		result->push_back(arr[l++]);
	}
	while (m <= right) {
		result->push_back(arr[m++]);
	}
	for (auto item : *result)
	{
		arr[left++] = item;
	}
}

void mergeSort(int arr[], int left, int right)
{
	if (right - left < 2)
	{
		if (arr[left] > arr[right])
		{
			std::swap(arr[left], arr[right]);
		}
		return;
	}
	int m = (right + left) / 2;
	mergeSort(arr, left, m);
	mergeSort(arr, m + 1, right);
	merge(arr, left, m + 1, right);
}

int main()
{
	int test[10];
	for (int i = 0; i < 10; ++i)
	{
		test[i] = std::rand() % 100;
	}
	std::cout << "排序前" << std::endl;
	for (int i = 0; i < 10; ++i)
	{
		std::cout << test[i] << " ";
	}
	std::cout << std::endl;
	mergeSort(test, 0, 9);
	std::cout << "排序后" << std::endl;
	for (int i = 0; i < 10; ++i)
	{
		std::cout << test[i] << " ";
	}
	std::cout << std::endl;
	return 0;
}

```

