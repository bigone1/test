## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

给定两个数组，编写一个函数来计算它们的交集。

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
		输出：[2,2]
		示例 2:

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
		输出：[4,9]

```c++
vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        vector<int> out;
        int i=0,j=0;
        while(i<nums1.size() && j<nums2.size()){
            if(nums1[i]==nums2[j]){
                out.push_back(nums1[i]);
                ++i;
                ++j;
            }
            else if(nums1[i] < nums2[j]){
                ++i;
            }
            else{
                ++j;
            }
        }
        return out;
    }
```

解题步骤如下：

<1>设定两个为0的指针，**比较两个指针的元素是否相等。** 如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。下图中我们的指针分别指向第一个元素，判断元素相等之后，将相同元素放到空白的数组。

![Error](https://github.com/bigone1/test/blob/master/Screenshots/30.png)

<2>如果两个指针的元素不相等，**我们将小的一个指针后移。** 图中我们指针移到下一个元素，判断不相等之后，将元素小的指针向后移动，继续进行判断。

![Error](https://github.com/bigone1/test/blob/master/Screenshots/31.png)

<3>反复以上步骤。

![Error](https://github.com/bigone1/test/blob/master/Screenshots/32.png)

<4>直到任意一个数组终止。

![Error](https://github.com/bigone1/test/blob/master/Screenshots/33.png)

## [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

输入: ["flower","flow","flight"]
		输出: "fl"
		示例 2:

输入: ["dog","racecar","car"]
		输出: ""
		解释: 输入不存在公共前缀。

```c++
string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()){
            return "";
        }
        int len=strs[0].size();
        int cnt=strs.size();
        for(int i=0;i<len;++i){
            char c=strs[0][i];
            for(int j=1;j<cnt;++j){
                if(i==strs[j].size() || strs[j][i]!=c){
                    return strs[0].substr(0,i);
                }
            }
        }
        return strs[0];
    }
```

纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。

## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```c++
//贪心
int maxProfit(vector<int>& prices) {
        int cnt=0;
        for(int i=1;i<prices.size();++i){
            if(prices[i]>prices[i-1]){
                cnt+=prices[i]-prices[i-1];
            }
        }
        return cnt;
    }
//动态规划
int maxProfit(vector<int>& prices) {
        if(prices.empty()){
            return 0;
        }
        int dp[prices.size()][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<prices.size();++i){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[prices.size()-1][0];
    }
```



## 万万没想到之抓捕孔连顺

给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择

1. 两个特工不能埋伏在同一地点

2. 三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用

   ```c++
   #include <iostream> 
   #include <vector>
   using namespace std;
    
   int main()
   {
       long long n, d, count = 0;
       cin>> n>> d;
       vector<long long> v(n);
       for (long long i = 0, j = 0; i < n; i++) {
           cin>> v[i];
           while (i >= 2 && (v[i] - v[j]) > d) {
               j++;
           }
           count += (i - j-1)*(i-j)/2;
       }
       cout << count % 99997867; 
       return 0;
   }
   ```

## 万万没想到之聪明的编辑

1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -> hello 

  2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -> hello 

3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC 

   ```c++
   #include<iostream>
   #include<string>
   using namespace std;
   
   int main(){
       int n;
       cin>>n;
       string s;
       for(int i=0;i<n;i++){
           cin>>s;
           int j=0;
           for(int k=0;k<s.size();k++){
               s[j++]=s[k];
               if(j>=4 && (s[j-1]==s[j-2] && s[j-3]==s[j-4])){
                   j--;
               }
               if(j>=3 && (s[j-3]==s[j-2] && s[j-2]==s[j-1])){
                   j--;
               }
           }
           cout<<s.substr(0,j)<<endl;
       }
   }
   ```

   

## 平衡括号串（一）

最少插入次数是得成为合法的括号串

```c++
int minAddToMakeValid(string str){
    //res记录插入次数
    int res=0;
    //need记录右括号的需求量
    int need=0;
    for(int i=0;i<str.size();i++){
        if(s[i]=='('){
            need++;
        }
        if(s[i]==')'){
            need--;
            if(need==-1){
                need=0;
                res++;
            }
        }
    }
    return res+need;
}
```



## 合法括号

```c++
char leftOf(char c) {
	if (c == ')') {
		return '(';
	}
	if (c == ']') {
		return '[';
	}
	return '{';
}

bool isValid(string str) {
	stack<char> s;
	for (char c : str) {
		if (c == '(' || c == '[' || c == '{') {
			s.push(c);
		}
		else {
			if (!s.empty() && leftOf(c) == s.top()) {
				s.pop();
			}
			else {
				return false;
			}
		}
	}
	return !s.empty();
}
```

## 排序算法

| 排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性       |
| -------- | -------------- | -------------- | ---------- | -------------------- |
| 冒泡排序 | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| 选择排序 | O(n2)          | O(n2)          | O(1)       | 数组不稳定、链表稳定 |
| 插入排序 | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| 快速排序 | O(n*log2n)     | O(n2)          | O(log2n)   | 不稳定               |
| 堆排序   | O(n*log2n)     | O(n*log2n)     | O(1)       | 不稳定               |
| 归并排序 | O(n*log2n)     | O(n*log2n)     | O(n)       | 稳定                 |
| 希尔排序 | O(n*log2n)     | O(n2)          | O(1)       | 不稳定               |
| 计数排序 | O(n+m)         | O(n+m)         | O(n+m)     | 稳定                 |
| 桶排序   | O(n)           | O(n)           | O(m)       | 稳定                 |
| 基数排序 | O(k*n)         | O(n2)          |            | 稳定                 |

```c++
// 冒泡排序 : N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次
/*
算法思想：
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
*/
void bubbleSort(vector<int> &vec){
    for (int i = 0; i < vec.size() - 1; i++) {
		for (int j = 0; j < vec.size() - i-1; j++) {
			if (vec[j] > vec[j+ 1]) {
				swap(vec[j], vec[j + 1]);
			}
		}
	}
}
/*
选择排序
算法思想：
1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
3. 以此类推，直到所有元素均排序完毕
*/
void SelectSort(vector<int> &vec)
{
    for (int i = 0; i < vec.size() - 1; i++) {
		int min = i;
		for (int j = i + 1; j < vec.size(); j++) {
			if (vec[j] < vec[min]) {
				min = j;
			}
		}
		swap(vec[i], vec[min]);
	}
}
/*
插入排序
算法思想：
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5
*/
void InsertSort(vector<int> &vec)
{
    int j;
	for (int i = 1; i < vec.size(); i++) {
		int cur = vec[i];
		for (j = i - 1; j >= 0 && vec[j] > cur; j--) {
			vec[j + 1] = vec[j];
		}
		vec[j + 1] = cur;
	}
}
/*
快速排序
算法思想：
1. 选取第一个数为基准
2. 将比基准小的数交换到前面，比基准大的数交换到后面
3. 对左右区间重复第二步，直到各区间只有一个数
*/

```

```c++
void kuaisu(vector<int> &vec,int l,int r) {
	if (l < r) {
		int i, j, x;
		i = l;
		j = r;
		x = vec[i];
		while (i < j) {
			while (i<j && vec[j]>x) {
				j--;
			}
			if (i < j) {
				vec[i++] = vec[j];
			}
			while (i < j && vec[i] < x) {
				i++;
			}
			if (i < j) {
				vec[j--] = vec[i];
			}
		}
		vec[i] = x;
		kuaisu(vec, l, i - 1);
		kuaisu(vec, i + 1, r);
	}
}
```



## 组合

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

```c++
		vector<int> tmp;
    vector<vector<int>> ans;

    void dfs(int cur,int n,int k){
        if(tmp.size()+n-cur+1<k){
            return;
        }
        if(tmp.size()==k){
            ans.push_back(tmp);
            return;
        }
      	//选择当前数
        tmp.push_back(cur);
        dfs(cur+1,n,k);
      	//不选择当前数
        tmp.pop_back();
        dfs(cur+1,n,k);
    }

    vector<vector<int>> combine(int n,int k){
        dfs(1,n,k);
        return ans;
    }
```



## 快速排序

```c++
int partition(vector<int>& nums, int l, int r) {
	int pivot = nums[r];
	int i = l - 1;
	for (int j = l; j <= r - 1; ++j) {
		if (nums[j] <= pivot) {
			i = i + 1;
			swap(nums[i], nums[j]);
		}
	}
	swap(nums[i + 1], nums[r]);
	return i + 1;
}
int randomized_partition(vector<int>& nums, int l, int r) {
	int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元
	swap(nums[r], nums[i]);
	return partition(nums, l, r);
}

void randomized_quicksort(vector<int>& nums, int l, int r) {
	if (l < r) {
		int pos = randomized_partition(nums, l, r);
		randomized_quicksort(nums, l, pos - 1);
		randomized_quicksort(nums, pos + 1, r);
	}
}

vector<int> quickSort(vector<int>& nums) {
	srand((unsigned)time(NULL));
	randomized_quicksort(nums, 0, (int)nums.size() - 1);
	return nums;
}
```

## 合并排序

```c++
class Solution {
    vector<int> tmp;
    void mergeSort(vector<int>& nums, int l, int r) {
        if (l >= r) return;
        int mid = (l + r) >> 1;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        int i = l, j = mid + 1;
        int cnt = 0;
        while (i <= mid && j <= r) {
            if (nums[i] < nums[j]) {
                tmp[cnt++] = nums[i++];
            }
            else {
                tmp[cnt++] = nums[j++];
            }
        }
        while (i <= mid) tmp[cnt++] = nums[i++];
        while (j <= r) tmp[cnt++] = nums[j++];
        for (int i = 0; i < r - l + 1; ++i) nums[i + l] = tmp[i];
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        tmp.resize((int)nums.size(), 0);
        mergeSort(nums, 0, (int)nums.size() - 1);
        return nums;
    }
};
```

## [N 皇后](https://leetcode-cn.com/problems/n-queens/)

```c++
class Solution {
private:
void backtracking(int n, int row, vector<string>& chessboard, vector<vector<string>>& result) {
    if (row == n) {
        result.push_back(chessboard);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (isValid(row, col, chessboard, n)) {
            chessboard[row][col] = 'Q';
            backtracking(n, row + 1, chessboard, result);
            chessboard[row][col] = '.';
        }
    }
}
bool isValid(int row, int col, vector<string>& chessboard, int n) {
    int count = 0;
    // 检查列
    for (int i = 0; i < row; i++) { // 这是一个剪枝
        if (chessboard[i][col] == 'Q') {
            return false;
        }
    }
    // 检查 45度角是否有皇后
    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    // 检查 135度角是否有皇后
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    return true;
}
public:
    vector<vector<string>> solveNQueens(int n) {
        std::vector<std::string> chessboard(n, std::string(n, '.'));
        vector<vector<string>> result;

        backtracking(n, 0, chessboard, result);
        return result;
    }
};
```

## [让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

给你一个字符串 `s` ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 `s` 成为回文串的 **最少操作次数** 。



```c++
int minInsertions(string s) {
        int n=s.size();
        vector<vector<int>> vec(n,vector(n,0));
        for(int i=n-2;i>=0;i--){
            for(int j=i+1;j<n;j++){
                if(s[i]==s[j]){
                    vec[i][j]=vec[i+1][j-1];
                }
                else{
                    vec[i][j]=min(vec[i+1][j],vec[i][j-1])+1;
                }
            }
        }
        return vec[0][n-1];
    }
```

## [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![Error](https://github.com/bigone1/test/blob/master/Screenshots/15.png)

```c++
//回溯法
void backtrack(vector<string> &out,unordered_map<char, string> &phone,int index,string &digits,string &com){
    if(index==digits.size()){
        out.push_back(com);
    }
    else{
        char digit=digits[index];
        string letter=phone.at(digit);
        for(char &c:letter){
            com.push_back(c);
            backtrack(out, phone, index+1, digits, com);
            com.pop_back();
        }
    }
}

vector<string> f(string &digits){
    vector<string> out;
    if(digits.empty()){
        return out;
    }
    unordered_map<char, string> phone{
        {'2',"abc"},
        {'3',"def"},
        {'4',"ghi"},
        {'5',"jkl"},
        {'6',"mno"},
        {'7',"pqrs"},
        {'8',"tuv"},
        {'9',"wxyz"}
    };
    string com;
    backtrack(out,phone,0,digits,com);
    return out;
}
```



## [重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

题解：如果长度为n的字符串s可以由一个长度为n'的子串s'重复构成，则n一定是n'的倍数，s'一定是s的前缀，对于任意的
$$
i∈[n′,n)，有 s[i]=s[i−n′]
$$

```c++
bool repeatedSubstringPattern(string s) {
        int n = s.size();
        for (int i = 1; i * 2 <= n; ++i) {
            if (n % i == 0) {
                bool match = true;
                for (int j = i; j < n; ++j) {
                    if (s[j] != s[j - i]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return true;
                }
            }
        }
        return false;
    }
```

## [字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

示例 1:

输入: num1 = "2", num2 = "3"
输出: "6"

示例 2:

输入: num1 = "123", num2 = "456"
输出: "56088"

```c++
string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") {
            return "0";
        }
        string ans = "0";
        int m = num1.size(), n = num2.size();
        for (int i = n - 1; i >= 0; i--) {
            string curr;
            int add = 0;
            for (int j = n - 1; j > i; j--) {
                curr.push_back(0);
            }
            int y = num2.at(i) - '0';
            for (int j = m - 1; j >= 0; j--) {
                int x = num1.at(j) - '0';
                int product = x * y + add;
                curr.push_back(product % 10);
                add = product / 10;
            }
            while (add != 0) {
                curr.push_back(add % 10);
                add /= 10;
            }
            reverse(curr.begin(), curr.end());
            for (auto &c : curr) {
                c += '0';
            }
            ans = addStrings(ans, curr);
        }
        return ans;
    }

    string addStrings(string &num1, string &num2) {
        int i = num1.size() - 1, j = num2.size() - 1, add = 0;
        string ans;
        while (i >= 0 || j >= 0 || add != 0) {
            int x = i >= 0 ? num1.at(i) - '0' : 0;
            int y = j >= 0 ? num2.at(j) - '0' : 0;
            int result = x + y + add;
            ans.push_back(result % 10);
            add = result / 10;
            i--;
            j--;
        }
        reverse(ans.begin(), ans.end());
        for (auto &c: ans) {
            c += '0';
        }
        return ans;
    }
```

## [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

![Error](https://github.com/bigone1/test/blob/master/Screenshots/12.png)

```c++
int numTrees(int n) {
        vector<int> vec(n + 1, 0);
        vec[0] = 1;
        vec[1] = 1;
        for(int i=2;i<=n;++i)
            for (int j = 1; j <= i; ++j) {
                vec[i] += vec[i - j] * vec[j - 1];
            }
        return vec[n];
    }
```

## 二叉树前序遍历-迭代法

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> out;
        if(root==NULL)
            return out;
        TreeNode* p;
        stack<TreeNode*> s;
        s.push(root);
        while(s.size()){
            p=s.top();
            out.push_back(p->val);
            s.pop();
            if(p->right)
                s.push(p->right);
            if(p->left)
                s.push(p->left);
        }
        return out;
    }
};
```

## 二叉树中序遍历-迭代法

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> out;
        if(root==NULL)
            return out;
        stack<TreeNode*> s;
        TreeNode *p=root;
        while(s.size()>0 || p!=NULL){
            while(p!=NULL){
                s.push(p);
                p=p->left;
            }
            if(s.size()>0){
                p=s.top();
                out.push_back(p->val);
                s.pop();
                p=p->right;
            }
        }
        return out;
    }
};
```

## 二叉树后序遍历-迭代法

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> out;
        if(root==NULL)
            return out;
        TreeNode* p;
        stack<TreeNode*> s;
        s.push(root);
        while(s.size()>0){
            p=s.top();
            s.pop();
            out.push_back(p->val);
            if(p->left)
                s.push(p->left);
            if(p->right)
                s.push(p->right);
        }
        reverse(out.begin(),out.end());
        return out;
    }
};
```

## 二叉树层序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> out;
        if(root==NULL)
            return out;
        queue<TreeNode*> q;   
        q.push(root);
        while(!q.empty()){
            vector<int> tmp;
            size_t len=q.size();
            for(size_t i=0;i<len;++i){
                TreeNode* p=q.front();
                tmp.push_back(p->val);
                q.pop();
                if(p->left)
                    q.push(p->left);
                if(p->right)
                    q.push(p->right);
            }
            out.push_back(tmp);
        }
        return out;
    }
};
```

## 设计循环队列

```c++
class MyCircularQueue {
private:
    vector<int> data;
    int head;
    int tail;
    int size;
public:
    /** Initialize your data structure here. Set the size of the queue to be k. */
    MyCircularQueue(int k) {
        data.resize(k);
        head = -1;
        tail = -1;
        size = k;
    }
    
    /** Insert an element into the circular queue. Return true if the operation is successful. */
    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        if (isEmpty()) {
            head = 0;
        }
        tail = (tail + 1) % size;
        data[tail] = value;
        return true;
    }
    
    /** Delete an element from the circular queue. Return true if the operation is successful. */
    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        if (head == tail) {
            head = -1;
            tail = -1;
            return true;
        }
        head = (head + 1) % size;
        return true;
    }
    
    /** Get the front item from the queue. */
    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[head];
    }
    
    /** Get the last item from the queue. */
    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[tail];
    }
    
    /** Checks whether the circular queue is empty or not. */
    bool isEmpty() {
        return head == -1;
    }
    
    /** Checks whether the circular queue is full or not. */
    bool isFull() {
        return ((tail + 1) % size) == head;
    }
};

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * bool param_1 = obj.enQueue(value);
 * bool param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * bool param_5 = obj.isEmpty();
 * bool param_6 = obj.isFull();
 */
```



## [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

示例 2：

输入: "cbbd"
输出: "bb"

```c++
int z(int Left, int Right,string s) {
        int L = Left;
        int R = Right;
        while (L >= 0 && R < s.length() && s[L] == s[R]) {
            L--;
            R++;
        }
        return R - L -1;
    }
    string longestPalindrome(string s) {
        if (s.size() == 0 || s.size() == 1)
		return s;
        int len = s.size();
        int start = 0;
        int end = 0;
        int m = 0;
        for (int i = 0; i < len; ++i) {
            int len1 = z(i, i, s);
            int len2 = z(i, i + 1, s);
            m = max(max(len1, len2), m);
            if (m > end - start + 1)
            {
                start = i - (m - 1) / 2;
                end = i + m / 2;
            }
        }
        return s.substr(start, m);
    }
```

## [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

    你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

```c++
int maxProfit(vector<int>& prices) {
        if (prices.empty())
                return 0;
        int len = prices.size();
        vector<vector<int>> vec(len+1, vector<int>(2));
        vec[0][0] = 0; vec[0][1] = INT_MIN;
        vec[1][0] = 0; vec[1][1] = -prices[0];
        for (int i = 2; i < len + 1; ++i) {
            vec[i][0] = max(vec[i - 1][0], vec[i - 1][1] + prices[i - 1]);
            vec[i][1] = max(vec[i - 1][1], vec[i - 2][0] - prices[i - 1]);
        }
        return vec[len][0];
    }
```

## [四数之和](https://leetcode-cn.com/problems/4sum/)

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

答案中不可以包含重复的四元组。

示例：

给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

```c++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
	vector<vector<int>> out;
	size_t len = nums.size();
	if (len < 4)
		return out;
	sort(nums.begin(), nums.end());
	for (size_t i = 0; i < len - 3; ++i) {
		if (nums[i] > 0 && target <= 0)
			break;
		if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)
			break;
		if (nums[i] + nums[len - 3] + nums[len - 2] + nums[len - 1] < target)
			continue;
		if (i > 0 && nums[i] == nums[i - 1])
			continue;
		for (size_t j = i + 1; j < len - 2; ++j) {
			if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target)
				break;
			if (nums[i] + nums[j] + nums[len - 2] + nums[len - 1] < target)
				continue;
			if (j > i + 1 && nums[j] == nums[j - 1])
				continue;
			size_t start = j + 1, end = len - 1;
			while (start < end) {
				int sum = nums[i] + nums[j] + nums[start] + nums[end];
				if (sum < target)
					start++;
				else if (sum > target)
					end--;
				else {
					out.push_back({ nums[i],nums[j],nums[start],nums[end] });
					int laststart = start, lastend = end;
					while (start < end && nums[start] == nums[laststart])
						start++;
					while (start < end && nums[end] == nums[lastend])
						end--;
				}
			}
		}
	}
	return out;
}
```

## 删数

有一个数组a[N]顺序存放0~N-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0->1->2(删除)->3->4->5(删除)->6->7->0(删除),如此循环直到最后一个数被删除。

输入描述:

```
每组数据为一行一个整数n(小于等于1000)，为数组成员数,如果大于1000，则对a[999]进行计算。
```

输出描述:

```
一行输出最后一个被删掉的数的原始下标位置。
```

输入例子1:

```
8
```

输出例子1:

```
6
```

```c++
#include <iostream>
#include<queue>
using namespace std;
int main()
{
	int N;
	while (cin >> N) {
		queue<int> q;
		for (int i = 0; i < N; ++i)
			q.push(i);
		int count = 0;
		while (q.size() != 1)
		{
			if (count != 2)
			{
				int a = q.front();
				q.push(a);
				q.pop();
				count++;
			}
			if (count == 2) {
				q.pop();
				count = 0;
			}
		}
		cout << q.front() << endl;
	}
	return 0;
}
```

## 字符集合

输入一个字符串，求出该字符串包含的字符集合

输入描述:

```
每组数据输入一个字符串，字符串最大长度为100，且只包含字母，不可能为空串，区分大小写。
```

输出描述:

```
每组数据一行，按字符串原有的字符顺序，输出字符集合，即重复出现并靠后的字母不输出。
```

输入例子1:

```
abcqweracb
```

输出例子1:

```
abcqwer
```

```c++
#include<iostream>
#include<string>
#include<set>
using namespace std;

int main() {
	string s;
	while (cin >> s) {
		set<char> se;
		string out="";
		for (size_t i = 0; i < s.size(); ++i)
		{
			if (se.find(s[i]) == se.end())
				out = out + s[i];
			se.insert(s[i]);	
		}
		cout << out << endl;
	}
}
```

  ## 汽水瓶

有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？  

输入描述:

```
输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1<=n<=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。
```

输出描述:

```
对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。
```

输入例子1:

```
3
10
81
0
```

输出例子1:

```
1
5
40
```

```c++
#include<iostream>
using namespace std;

int main() {
	int N;
	while (cin >> N && N != 0) {
		int shui = 0;
		while (N != 1) {
			int shang = N / 3;
			int yu = N % 3;
			shui = shui + shang;
			N = shang + yu;
			if (N == 2)
				N = N + 1;
		}
		cout << shui << endl;
	}
	return 0;
}
```

## 明明的随机数

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 
 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 

  样例输入解释： 

  样例有两组测试 

  第一组是3个数字，分别是：2，2，1。 

  第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。

输入描述:

```
输入多行，先输入随机整数的个数，再输入相应个数的整数
```

输出描述:

```
返回多行，处理后的结果
```

输入例子1:

```
3
2
2
1
11
10
20
40
32
67
40
20
89
300
400
15
```

输出例子1:

```
1
2
10
15
20
32
40
67
89
300
400
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	int N,n;
	while (cin >> N) {
		vector<int> vec;
		for (int i = 0; i < N; ++i) {
			cin >> n;
			vec.push_back(n);
		}
		sort(vec.begin(), vec.end());
		vector<int>::iterator it = unique(vec.begin(), vec.end());
		for (vector<int>::iterator i = vec.begin(); i != it; ++i)
			cout << *i << endl;
	}
	return 0;
}
```

## 进制转换

写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）  

输入描述:

```
输入一个十六进制的数值字符串。
```

输出描述:

```
输出该数值的十进制字符串。
```

输入例子1:

```
0xA
```

输出例子1:

```
10
```

```c++
#include<iostream>
#include<string>
#include<map>
#include<cmath>
using namespace std;

int main() {
	string s;
    while(getline(cin,s)){
        string s1=s.substr(2);
        reverse(s1.begin(),s1.end());
        string tmp="0123456789ABCDEF";
        int out=0;
        for(int i=0;i<s1.size();i++){
            out=out+tmp.find(s1[i])*pow(16,i);
        }
        cout<<out<<endl;
    }
}
```

## 扑克牌大小

扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A，2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）:) 
 3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER 
 输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：4 4 4 4-joker JOKER
 请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR

 基本规则：
 （1）输入每手牌可能是个子，对子，顺子（连续5张），三个，炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列；
 （2）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子）
 （3）大小规则跟大家平时了解的常见规则相同，个子，对子，三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌；
 （4）输入的两手牌不会出现相等的情况。

 答案提示：
 （1）除了炸弹和对王之外，其他必须同类型比较。
 （2）输入已经保证合法性，不用检查输入是否是合法的牌。
 （3）输入的顺子已经经过从小到大排序，因此不用再排序了.

输入描述:

```
输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如4 4 4 4-joker JOKER。
```

输出描述:**

```
输出两手牌中较大的那手，不含连接符，扑克牌顺序不变，仍以空格隔开；如果不存在比较关系则输出ERROR。
```

输入例子1:**

```
4 4 4 4-joker JOKER
```

输出例子1:**

```
joker JOKER
```

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;

int main(){
    string s;
    while(getline(cin, s)){
        if(s.find("joker JOKER")!=-1){
            cout<<"joker JOKER"<<endl;
        }
        else{
            int hen=s.find('-');
            string qian=s.substr(0,hen);
            string hou=s.substr(hen+1);
            int c1=count(qian.begin(),qian.end(),' ');
            int c2=count(hou.begin(),hou.end(),' ');
            string fqian=qian.substr(0,qian.find(' '));
            string fhou=hou.substr(0,hou.find(' '));
            string str="345678910JQKA2jokerJOKER";
            if(c1==c2){
                if(str.find(fqian)>str.find(fhou)){
                    cout<<qian<<endl;
                }
                else{
                    cout<<hou<<endl;
                }
            }
            else{
                if(c1==3){
                    cout<<qian<<endl;
                }
                else if(c2==3){
                    cout<<hou<<endl;
                }
                else{
                    cout<<"ERROR"<<endl;
                }
            }
        }
    }
}
```

## 简单错误记录

开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。 
  处理:
  1.记录最多8条错误记录，对相同的错误记录(即文件名称和行号完全匹配)只记录一条，错误计数增加；(文件所在的目录不同，文件名和行号相同也要合并)
  2.超过16个字符的文件名称，只记录文件的最后有效16个字符；(如果文件名不同，而只是文件名的后16个字符和行号相同，也不要合并)
  3.输入的文件可能带路径，记录文件名称不能带路径

输入描述:**

```
一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。
    文件路径为windows格式
    如：E:\V1R2\product\fpgadrive.c 1325
```

输出描述:**

```
将所有的记录统计并将结果输出，格式：文件名代码行数数目，一个空格隔开，如: fpgadrive.c 1325 1 
    结果根据数目从多到少排序，数目相同的情况下，按照输入第一次出现顺序排序。
    如果超过8条记录，则只输出前8条记录.
    如果文件名的长度超过16个字符，则只输出后16个字符
```

输入例子1:**

```
E:\V1R2\product\fpgadrive.c 1325
```

输出例子1:**

```
fpgadrive.c 1325 1
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
using namespace std;

bool compare(pair<string,int> v1,pair<string,int> v2){
    return v1.second>v2.second;
}

int main(){
    string s;
    vector<pair<string,int>> out;
    while(getline(cin,s)){
        if(s.size()==0)
            break;
        int xiegang=s.rfind('\\');
        string tmp=s.substr(xiegang+1);
        out.push_back(make_pair(tmp,1));
        for(int i=0;i<out.size()-1;i++){
            if(out[i].first==tmp){
                out[i].second++;
                out.pop_back();
                break;
            }
        }
    }
    stable_sort(out.begin(),out.end(),compare);
    for(int i=0;i<8&&i<out.size();i++){
        int kong=out[i].first.find(' ');
        if(kong>16){
            cout<<out[i].first.erase(0,kong-16)<<" "<<out[i].second<<endl;
        }
        else
            cout<<out[i].first<<" "<<out[i].second<<endl;
    }
}
```

## 最高分是多少

老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩.

输入描述:**

```
输入包括多组测试数据。
每组输入第一行是两个正整数N和M（0 < N <= 30000,0 < M < 5000）,分别代表学生的数目和操作的数目。
学生ID编号从1编到N。
第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩
接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为'Q'的时候, 表示这是一条询问操作，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少
当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。
```

输出描述:**

```
对于每一次询问操作，在一行里面输出最高成绩.
```

输入例子1:**

```
5 7
1 2 3 4 5
Q 1 5
U 3 6
Q 3 4
Q 4 5
U 4 5
U 2 9
Q 1 5
```

输出例子1:**

```
5
6
5
9
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main(){
    int N,M;
    while(cin>>N>>M){
        vector<int> vec(N+1,0);
        for(int i=1;i<=N;i++)
            cin>>vec[i];
        char c;
        int first,second;
        for(int j=0;j<M;j++){
            cin>>c>>first>>second;
            if(c=='U')
                vec[first]=second;
            else{
                if(first>second)
                    swap(first,second);
                cout<<*max_element(vec.begin()+first,vec.begin()+second+1)<<endl;
            }
        }
    }
}
```

## 字符集合

输入一个字符串，求出该字符串包含的字符集合

输入描述:**

```
每组数据输入一个字符串，字符串最大长度为100，且只包含字母，不可能为空串，区分大小写。
```

输出描述:**

```
每组数据一行，按字符串原有的字符顺序，输出字符集合，即重复出现并靠后的字母不输出。
```

输入例子1:**

```
abcqweracb
```

输出例子1:**

```
abcqwer
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main(){
    string s;
    while(getline(cin,s)){
        vector<char> vec;
        for(int i=0;i<s.size();i++){
            if(count(vec.begin(),vec.end(),s[i])!=1)
                vec.push_back(s[i]);
            else
                continue;
        }
        string out="";
        for(auto c:vec)
            out+=c;
        cout<<out<<endl;
    }
}
```

## 数独

  数独是一个我们都非常熟悉的经典游戏，运用计算机我们可以很快地解开数独难题，现在有一些简单的数独题目，请编写一个程序求解。 

  如有多解，输出一个解 

输入描述:**

```
输入9行，每行为空格隔开的9个数字，为0的地方就是需要填充的。
```

输出描述:**

```
输出九行，每行九个空格隔开的数字，为解出的答案。
```

```c++
#include <iostream>
#include <cstring>
#include <set>
using namespace std;
bool solveQues(int question[9][9])
{
    set<int> numpos;

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (question[i][j] == 0) {
                for (int k = 0; k < 9; k++) {
                    numpos.insert(question[i][k]);
                    numpos.insert(question[k][j]);
                }

                for (int m = 0; m < 3; m++) {
                    for (int n = 0; n < 3; n++) {
                        numpos.insert(question[i/3*3+m][j/3*3+n]);
                    }
                }

                if (numpos.size() == 10) {
                    return false;
                }

                for (int k = 1; k < 10; k++) {
                    if (numpos.find(k) == numpos.end()) {
                        question[i][j] = k;
                        if (solveQues(question)) {
                            return true;
                        }
                    }
                }
                question[i][j] = 0;
                return false;
            }
        }
    }
    return true;
}

int main()
{
    int a;

    while (cin >> a) {
        int question[9][9];
        question[0][0] = a;

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (i == 0 && j == 0) {
                    continue;
                }
                cin >> question[i][j];
            }
        }

        if (solveQues(question) ){
            for (int i = 0; i < 9; i++) {
                cout << question[i][0];
                for (int j =1; j < 9; j++) {
                    cout << " "<< question[i][j];
                }
                cout << endl;
            }
        }
    }
    return 0;
}
```

## 整数拆分

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

```c++
int integerBreak(int n) {
        vector<int> vec(n+1);
        for(int i=2;i<=n;i++){
            int cur=0;
            for(int j=1;j<i;j++){
                cur=max(cur,max(j*(i-j),j*vec[i-j]));
            }
            vec[i]=cur;
        }
        return vec[n];
    }
```

## 反转字符串---递归

```c++
class Solution {
public:
    void rev(vector<char>&s,int start,int end){
        if(start>=end)
            return;
        swap(s[start],s[end]);
        rev(s,++start,--end);
    }
    void reverseString(vector<char>& s) {
        int len=s.size();
        if(len==0||len==1)
            return;
        rev(s,0,len-1);
    }
};
```

## 两两交换链表中的节点

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head||!head->next)
            return head;
        ListNode *first=head;
        ListNode *second=head->next;
        head=second;
        first->next=swapPairs(second->next);
        second->next=first;
        return head;
    }
};
```
