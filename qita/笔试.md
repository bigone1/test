#### [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

![Error](https://github.com/bigone1/test/blob/master/Screenshots/12.png)

```c++
int numTrees(int n) {
        vector<int> vec(n + 1, 0);
        vec[0] = 1;
        vec[1] = 1;
        for(int i=2;i<=n;++i)
            for (int j = 1; j <= i; ++j) {
                vec[i] += vec[i - j] * vec[j - 1];
            }
        return vec[n];
    }
```

#### 二叉树前序遍历-迭代法

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> out;
        if(root==NULL)
            return out;
        TreeNode* p;
        stack<TreeNode*> s;
        s.push(root);
        while(s.size()){
            p=s.top();
            out.push_back(p->val);
            s.pop();
            if(p->right)
                s.push(p->right);
            if(p->left)
                s.push(p->left);
        }
        return out;
    }
};
```

#### 二叉树中序遍历-迭代法

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> out;
        if(root==NULL)
            return out;
        stack<TreeNode*> s;
        TreeNode *p=root;
        while(s.size()>0 || p!=NULL){
            while(p!=NULL){
                s.push(p);
                p=p->left;
            }
            if(s.size()>0){
                p=s.top();
                out.push_back(p->val);
                s.pop();
                p=p->right;
            }
        }
        return out;
    }
};
```

#### 二叉树后序遍历-迭代法

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> out;
        if(root==NULL)
            return out;
        TreeNode* p;
        stack<TreeNode*> s;
        s.push(root);
        while(s.size()>0){
            p=s.top();
            s.pop();
            out.push_back(p->val);
            if(p->left)
                s.push(p->left);
            if(p->right)
                s.push(p->right);
        }
        reverse(out.begin(),out.end());
        return out;
    }
};
```

#### 二叉树层序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> out;
        if(root==NULL)
            return out;
        queue<TreeNode*> q;   
        q.push(root);
        while(!q.empty()){
            vector<int> tmp;
            size_t len=q.size();
            for(size_t i=0;i<len;++i){
                TreeNode* p=q.front();
                tmp.push_back(p->val);
                q.pop();
                if(p->left)
                    q.push(p->left);
                if(p->right)
                    q.push(p->right);
            }
            out.push_back(tmp);
        }
        return out;
    }
};
```

#### 设计循环队列

```c++
class MyCircularQueue {
private:
    vector<int> data;
    int head;
    int tail;
    int size;
public:
    /** Initialize your data structure here. Set the size of the queue to be k. */
    MyCircularQueue(int k) {
        data.resize(k);
        head = -1;
        tail = -1;
        size = k;
    }
    
    /** Insert an element into the circular queue. Return true if the operation is successful. */
    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        if (isEmpty()) {
            head = 0;
        }
        tail = (tail + 1) % size;
        data[tail] = value;
        return true;
    }
    
    /** Delete an element from the circular queue. Return true if the operation is successful. */
    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        if (head == tail) {
            head = -1;
            tail = -1;
            return true;
        }
        head = (head + 1) % size;
        return true;
    }
    
    /** Get the front item from the queue. */
    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[head];
    }
    
    /** Get the last item from the queue. */
    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[tail];
    }
    
    /** Checks whether the circular queue is empty or not. */
    bool isEmpty() {
        return head == -1;
    }
    
    /** Checks whether the circular queue is full or not. */
    bool isFull() {
        return ((tail + 1) % size) == head;
    }
};

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * bool param_1 = obj.enQueue(value);
 * bool param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * bool param_5 = obj.isEmpty();
 * bool param_6 = obj.isFull();
 */
```



#### [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

示例 2：

输入: "cbbd"
输出: "bb"

```c++
int z(int Left, int Right,string s) {
        int L = Left;
        int R = Right;
        while (L >= 0 && R < s.length() && s[L] == s[R]) {
            L--;
            R++;
        }
        return R - L -1;
    }
    string longestPalindrome(string s) {
        if (s.size() == 0 || s.size() == 1)
		return s;
        int len = s.size();
        int start = 0;
        int end = 0;
        int m = 0;
        for (int i = 0; i < len; ++i) {
            int len1 = z(i, i, s);
            int len2 = z(i, i + 1, s);
            m = max(max(len1, len2), m);
            if (m > end - start + 1)
            {
                start = i - (m - 1) / 2;
                end = i + m / 2;
            }
        }
        return s.substr(start, m);
    }
```

#### [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

    你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

```c++
int maxProfit(vector<int>& prices) {
        if (prices.empty())
                return 0;
        int len = prices.size();
        vector<vector<int>> vec(len+1, vector<int>(2));
        vec[0][0] = 0; vec[0][1] = INT_MIN;
        vec[1][0] = 0; vec[1][1] = -prices[0];
        for (int i = 2; i < len + 1; ++i) {
            vec[i][0] = max(vec[i - 1][0], vec[i - 1][1] + prices[i - 1]);
            vec[i][1] = max(vec[i - 1][1], vec[i - 2][0] - prices[i - 1]);
        }
        return vec[len][0];
    }
```

#### [四数之和](https://leetcode-cn.com/problems/4sum/)

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

答案中不可以包含重复的四元组。

示例：

给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

```c++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
	vector<vector<int>> out;
	size_t len = nums.size();
	if (len < 4)
		return out;
	sort(nums.begin(), nums.end());
	for (size_t i = 0; i < len - 3; ++i) {
		if (nums[i] > 0 && target <= 0)
			break;
		if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)
			break;
		if (nums[i] + nums[len - 3] + nums[len - 2] + nums[len - 1] < target)
			continue;
		if (i > 0 && nums[i] == nums[i - 1])
			continue;
		for (size_t j = i + 1; j < len - 2; ++j) {
			if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target)
				break;
			if (nums[i] + nums[j] + nums[len - 2] + nums[len - 1] < target)
				continue;
			if (j > i + 1 && nums[j] == nums[j - 1])
				continue;
			size_t start = j + 1, end = len - 1;
			while (start < end) {
				int sum = nums[i] + nums[j] + nums[start] + nums[end];
				if (sum < target)
					start++;
				else if (sum > target)
					end--;
				else {
					out.push_back({ nums[i],nums[j],nums[start],nums[end] });
					int laststart = start, lastend = end;
					while (start < end && nums[start] == nums[laststart])
						start++;
					while (start < end && nums[end] == nums[lastend])
						end--;
				}
			}
		}
	}
	return out;
}
```

#### 删数

有一个数组a[N]顺序存放0~N-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0->1->2(删除)->3->4->5(删除)->6->7->0(删除),如此循环直到最后一个数被删除。

输入描述:

```
每组数据为一行一个整数n(小于等于1000)，为数组成员数,如果大于1000，则对a[999]进行计算。
```

输出描述:

```
一行输出最后一个被删掉的数的原始下标位置。
```

输入例子1:

```
8
```

输出例子1:

```
6
```

```c++
#include <iostream>
#include<queue>
using namespace std;
int main()
{
	int N;
	while (cin >> N) {
		queue<int> q;
		for (int i = 0; i < N; ++i)
			q.push(i);
		int count = 0;
		while (q.size() != 1)
		{
			if (count != 2)
			{
				int a = q.front();
				q.push(a);
				q.pop();
				count++;
			}
			if (count == 2) {
				q.pop();
				count = 0;
			}
		}
		cout << q.front() << endl;
	}
	return 0;
}
```

#### 字符集合

输入一个字符串，求出该字符串包含的字符集合

输入描述:

```
每组数据输入一个字符串，字符串最大长度为100，且只包含字母，不可能为空串，区分大小写。
```

输出描述:

```
每组数据一行，按字符串原有的字符顺序，输出字符集合，即重复出现并靠后的字母不输出。
```

输入例子1:

```
abcqweracb
```

输出例子1:

```
abcqwer
```

```c++
#include<iostream>
#include<string>
#include<set>
using namespace std;

int main() {
	string s;
	while (cin >> s) {
		set<char> se;
		string out="";
		for (size_t i = 0; i < s.size(); ++i)
		{
			if (se.find(s[i]) == se.end())
				out = out + s[i];
			se.insert(s[i]);	
		}
		cout << out << endl;
	}
}
```

  #### 汽水瓶

有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？  

输入描述:

```
输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1<=n<=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。
```

输出描述:

```
对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。
```

输入例子1:

```
3
10
81
0
```

输出例子1:

```
1
5
40
```

```c++
#include<iostream>
using namespace std;

int main() {
	int N;
	while (cin >> N && N != 0) {
		int shui = 0;
		while (N != 1) {
			int shang = N / 3;
			int yu = N % 3;
			shui = shui + shang;
			N = shang + yu;
			if (N == 2)
				N = N + 1;
		}
		cout << shui << endl;
	}
	return 0;
}
```

#### 明明的随机数

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 
 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 

  样例输入解释： 

  样例有两组测试 

  第一组是3个数字，分别是：2，2，1。 

  第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。

输入描述:

```
输入多行，先输入随机整数的个数，再输入相应个数的整数
```

输出描述:

```
返回多行，处理后的结果
```

输入例子1:

```
3
2
2
1
11
10
20
40
32
67
40
20
89
300
400
15
```

输出例子1:

```
1
2
10
15
20
32
40
67
89
300
400
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	int N,n;
	while (cin >> N) {
		vector<int> vec;
		for (int i = 0; i < N; ++i) {
			cin >> n;
			vec.push_back(n);
		}
		sort(vec.begin(), vec.end());
		vector<int>::iterator it = unique(vec.begin(), vec.end());
		for (vector<int>::iterator i = vec.begin(); i != it; ++i)
			cout << *i << endl;
	}
	return 0;
}
```

#### 进制转换

写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）  

输入描述:

```
输入一个十六进制的数值字符串。
```

输出描述:

```
输出该数值的十进制字符串。
```

输入例子1:

```
0xA
```

输出例子1:

```
10
```

```c++
#include<iostream>
#include<string>
#include<map>
#include<cmath>
using namespace std;

int main() {
	string s;
	map<char, int> m{ {'0',0},{'1',1},{'2',2},{'3',3},{'4',4},{'5',5},{'6',6},{'7',7},{'8',8},{'9',9},{'A',10},{'B',11},{'C',12},{'D',13},{'E',14},{'F',15}};
	while (getline(cin, s)) {
		int out = 0;
		size_t t = s.size()-3;
		for (size_t i = 2; i < s.size(); ++i)
		{
			out = out + m[s[i]] * pow(16,t);
			t = t - 1;
		}
		cout << out << endl;
	}
}
```

#### 归并排序

```c++
#include<iostream>
#include<vector>
using namespace std;

void merge(int arr[], int left, int mid, int right)
{
	std::vector<int> *result = new std::vector<int>();
	int l = left;
	int m = mid;
	while (l <= mid - 1 && m <= right)
	{
		if (arr[l] <= arr[m]) {
			result->push_back(arr[l++]);
		}
		else {
			result->push_back(arr[m++]);
		}
	}
	while (l <= mid - 1) {
		result->push_back(arr[l++]);
	}
	while (m <= right) {
		result->push_back(arr[m++]);
	}
	for (auto item : *result)
	{
		arr[left++] = item;
	}
}

void mergeSort(int arr[], int left, int right)
{
	if (right - left < 2)
	{
		if (arr[left] > arr[right])
		{
			std::swap(arr[left], arr[right]);
		}
		return;
	}
	int m = (right + left) / 2;
	mergeSort(arr, left, m);
	mergeSort(arr, m + 1, right);
	merge(arr, left, m + 1, right);
}

int main()
{
	int test[10];
	for (int i = 0; i < 10; ++i)
	{
		test[i] = std::rand() % 100;
	}
	std::cout << "排序前" << std::endl;
	for (int i = 0; i < 10; ++i)
	{
		std::cout << test[i] << " ";
	}
	std::cout << std::endl;
	mergeSort(test, 0, 9);
	std::cout << "排序后" << std::endl;
	for (int i = 0; i < 10; ++i)
	{
		std::cout << test[i] << " ";
	}
	std::cout << std::endl;
	return 0;
}

```

#### 扑克牌大小

扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A，2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）:) 
 3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER 
 输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：4 4 4 4-joker JOKER
 请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR

 基本规则：
 （1）输入每手牌可能是个子，对子，顺子（连续5张），三个，炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列；
 （2）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子）
 （3）大小规则跟大家平时了解的常见规则相同，个子，对子，三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌；
 （4）输入的两手牌不会出现相等的情况。

 答案提示：
 （1）除了炸弹和对王之外，其他必须同类型比较。
 （2）输入已经保证合法性，不用检查输入是否是合法的牌。
 （3）输入的顺子已经经过从小到大排序，因此不用再排序了.

输入描述:

```
输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如4 4 4 4-joker JOKER。
```

输出描述:**

```
输出两手牌中较大的那手，不含连接符，扑克牌顺序不变，仍以空格隔开；如果不存在比较关系则输出ERROR。
```

输入例子1:**

```
4 4 4 4-joker JOKER
```

输出例子1:**

```
joker JOKER
```

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;

int main(){
    string s;
    while(getline(cin, s)){
        if(s.find("joker JOKER")!=-1){
            cout<<"joker JOKER"<<endl;
        }
        else{
            int hen=s.find('-');
            string qian=s.substr(0,hen);
            string hou=s.substr(hen+1);
            int c1=count(qian.begin(),qian.end(),' ');
            int c2=count(hou.begin(),hou.end(),' ');
            string fqian=qian.substr(0,qian.find(' '));
            string fhou=hou.substr(0,hou.find(' '));
            string str="345678910JQKA2jokerJOKER";
            if(c1==c2){
                if(str.find(fqian)>str.find(fhou)){
                    cout<<qian<<endl;
                }
                else{
                    cout<<hou<<endl;
                }
            }
            else{
                if(c1==3){
                    cout<<qian<<endl;
                }
                else if(c2==3){
                    cout<<hou<<endl;
                }
                else{
                    cout<<"ERROR"<<endl;
                }
            }
        }
    }
}
```

#### 简单错误记录

开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。 
  处理:
  1.记录最多8条错误记录，对相同的错误记录(即文件名称和行号完全匹配)只记录一条，错误计数增加；(文件所在的目录不同，文件名和行号相同也要合并)
  2.超过16个字符的文件名称，只记录文件的最后有效16个字符；(如果文件名不同，而只是文件名的后16个字符和行号相同，也不要合并)
  3.输入的文件可能带路径，记录文件名称不能带路径

输入描述:**

```
一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。
    文件路径为windows格式
    如：E:\V1R2\product\fpgadrive.c 1325
```

输出描述:**

```
将所有的记录统计并将结果输出，格式：文件名代码行数数目，一个空格隔开，如: fpgadrive.c 1325 1 
    结果根据数目从多到少排序，数目相同的情况下，按照输入第一次出现顺序排序。
    如果超过8条记录，则只输出前8条记录.
    如果文件名的长度超过16个字符，则只输出后16个字符
```

输入例子1:**

```
E:\V1R2\product\fpgadrive.c 1325
```

输出例子1:**

```
fpgadrive.c 1325 1
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
using namespace std;

bool compare(pair<string,int> v1,pair<string,int> v2){
    return v1.second>v2.second;
}

int main(){
    string s;
    vector<pair<string,int>> out;
    while(getline(cin,s)){
        if(s.size()==0)
            break;
        int xiegang=s.rfind('\\');
        string tmp=s.substr(xiegang+1);
        out.push_back(make_pair(tmp,1));
        for(int i=0;i<out.size()-1;i++){
            if(out[i].first==tmp){
                out[i].second++;
                out.pop_back();
                break;
            }
        }
    }
    stable_sort(out.begin(),out.end(),compare);
    for(int i=0;i<8&&i<out.size();i++){
        int kong=out[i].first.find(' ');
        if(kong>16){
            cout<<out[i].first.erase(0,kong-16)<<" "<<out[i].second<<endl;
        }
        else
            cout<<out[i].first<<" "<<out[i].second<<endl;
    }
}
```

#### 最高分是多少

老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩.

输入描述:**

```
输入包括多组测试数据。
每组输入第一行是两个正整数N和M（0 < N <= 30000,0 < M < 5000）,分别代表学生的数目和操作的数目。
学生ID编号从1编到N。
第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩
接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为'Q'的时候, 表示这是一条询问操作，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少
当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。
```

输出描述:**

```
对于每一次询问操作，在一行里面输出最高成绩.
```

输入例子1:**

```
5 7
1 2 3 4 5
Q 1 5
U 3 6
Q 3 4
Q 4 5
U 4 5
U 2 9
Q 1 5
```

输出例子1:**

```
5
6
5
9
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main(){
    int N,M;
    while(cin>>N>>M){
        vector<int> vec(N+1,0);
        for(int i=1;i<=N;i++)
            cin>>vec[i];
        char c;
        int first,second;
        for(int j=0;j<M;j++){
            cin>>c>>first>>second;
            if(c=='U')
                vec[first]=second;
            else{
                if(first>second)
                    swap(first,second);
                cout<<*max_element(vec.begin()+first,vec.begin()+second+1)<<endl;
            }
        }
    }
}
```

#### 字符集合

输入一个字符串，求出该字符串包含的字符集合

输入描述:**

```
每组数据输入一个字符串，字符串最大长度为100，且只包含字母，不可能为空串，区分大小写。
```

输出描述:**

```
每组数据一行，按字符串原有的字符顺序，输出字符集合，即重复出现并靠后的字母不输出。
```

输入例子1:**

```
abcqweracb
```

输出例子1:**

```
abcqwer
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main(){
    string s;
    while(getline(cin,s)){
        vector<char> vec;
        for(int i=0;i<s.size();i++){
            if(count(vec.begin(),vec.end(),s[i])!=1)
                vec.push_back(s[i]);
            else
                continue;
        }
        string out="";
        for(auto c:vec)
            out+=c;
        cout<<out<<endl;
    }
}
```

#### 数独

  数独是一个我们都非常熟悉的经典游戏，运用计算机我们可以很快地解开数独难题，现在有一些简单的数独题目，请编写一个程序求解。 

  如有多解，输出一个解 

输入描述:**

```
输入9行，每行为空格隔开的9个数字，为0的地方就是需要填充的。
```

输出描述:**

```
输出九行，每行九个空格隔开的数字，为解出的答案。
```

```c++
#include <iostream>
#include <cstring>
#include <set>
using namespace std;
bool solveQues(int question[9][9])
{
    set<int> numpos;

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (question[i][j] == 0) {
                for (int k = 0; k < 9; k++) {
                    numpos.insert(question[i][k]);
                    numpos.insert(question[k][j]);
                }

                for (int m = 0; m < 3; m++) {
                    for (int n = 0; n < 3; n++) {
                        numpos.insert(question[i/3*3+m][j/3*3+n]);
                    }
                }

                if (numpos.size() == 10) {
                    return false;
                }

                for (int k = 1; k < 10; k++) {
                    if (numpos.find(k) == numpos.end()) {
                        question[i][j] = k;
                        if (solveQues(question)) {
                            return true;
                        }
                    }
                }
                question[i][j] = 0;
                return false;
            }
        }
    }
    return true;
}

int main()
{
    int a;

    while (cin >> a) {
        int question[9][9];
        question[0][0] = a;

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (i == 0 && j == 0) {
                    continue;
                }
                cin >> question[i][j];
            }
        }

        if (solveQues(question) ){
            for (int i = 0; i < 9; i++) {
                cout << question[i][0];
                for (int j =1; j < 9; j++) {
                    cout << " "<< question[i][j];
                }
                cout << endl;
            }
        }
    }
    return 0;
}
```

#### 整数拆分

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

```c++
int integerBreak(int n) {
        vector<int> vec(n+1);
        for(int i=2;i<=n;i++){
            int cur=0;
            for(int j=1;j<i;j++){
                cur=max(cur,max(j*(i-j),j*vec[i-j]));
            }
            vec[i]=cur;
        }
        return vec[n];
    }
```

