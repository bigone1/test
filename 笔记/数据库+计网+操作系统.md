## **数据库** 

### Q1：MySQL主要有哪些存储引擎，分别适合哪些应用场景？

答：主要有①MyISAM，是5.5版本之前的默认存储引擎，支持表级锁，不支持事务和外键，并发效率较低，读取数据快，更新数据慢。适合以读操作为主，并且对并发性要求较低的应用。②InnoDB，MySQL目前的默认存储引擎，支持行级锁、事务和外键，**并发效率好。适合对事务的完整性和并发性、数据的准确性要求比较高，增删操作多的应用。**③Memory，所有的数据都保存在**内存**中，访问速度快，一旦服务关闭数据将丢失。适合**更新不太频繁的数据量小的表**用来快速得到访问结果。④Archive、Federated等。

### Q2：索引是什么？

答：MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，**这些数据结构以某种方式引用（指向）数据**， 这样就**可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。**

### ***Q3：索引的优缺点有哪些？

答：①优势：提高数据检索的效率，**降低数据库的IO成本。**通过索引列对数据进行排序，**降低数据排序的成本，降低CPU的消耗**。②劣势：实际上**索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录**，所以索引列也是要占用空间的。 虽然索引大大提高了查询效率，同时却**也降低更新表的速度**，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。

```
为什么要创建索引呢？这是因为，创建索引可以大大提高系统的性能。
第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

第一，创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。
第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
```

```
一般来说，应该在这些列 上创建索引，例如：

在经常需要搜索的列上，可以加快搜索的速度；
在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；
在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。


同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：

第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因 为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
第二，对于那 些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

总结:
1.创建索引的列:
经常需要查询,主键,用于连接,范围查找,排序
2.不能用于索引的:
不经常查询的,只有少数数值的列(增加索引的效果不是很好),当修改性能远大于检索时候
```

### Q4：MySQL支持哪几种索引？(4)

答：①BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。②HASH 索引：只有Memory引擎支持 ， 使用场景简单 。③R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。④Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。

### Q5：B+树是什么和B树有什么区别？

答：**①BTree又叫多路平衡搜索树**，一颗m叉的BTree特性如下： 树中每个节点最多包含m个孩子。 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。若根节点不是叶子节点，则至少有两个孩子。所有的叶子节点都在同一层。每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] <= n <= m-1。②B+Tree为BTree的变种，B+Tree与BTree的区别为： n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。 B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。所有的非叶子节点都可以看作是key的索引部分。③由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。

### ***Q6：MySQL的索引对B+树做了哪些优化？

答：MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。B+树是多叉平衡搜索树,从根节点到每个叶子节点的高度差值不超过1

B+树相对与B树在查询上有优势:

1. B树的非叶子节点也会保存数据,而B+树只有叶子结点才保存数据,非叶子结点保存的仍然是索引.

2. B+树的查找更加稳定
3. B+树为每个叶子结点增加了指向相邻叶子结点的链表指针,这样对于范围查找有利.

### Q7：索引有哪些分类？

答：①单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引。②唯一索引 ：索引列的值必须唯一，但允许有空值。③复合索引 ：即一个索引包含多个列。主键索引不为空

### Q8：数据库的索引创建有哪些设计原则？

答：①对查询频次较高，数据量较大的表创建索引。②限制索引数量：对于增删改操作较多的表，如果索引过多将需要很高的维护代价，降低操作效率，增加操作耗时。③利用最左前缀：如果索引字段值过长，会降低索引的执行效率。④删除不常用索引。⑤使用唯一索引，区分度越高，效率越高。⑤使用短索引，如果索引值很长则占用磁盘变大，会影响效。⑥为常作为查询条件、经常需要排序、分组和联合操作的字段建立索引。⑦尽量扩展现有索引，联合索引的效率高于多个独立索引。

### Q9：索引在什么情况下会失效?(6)

答：①复合索引未使用最左列索引时或跳跃使用时失效，例如以name，age和sex字段建立索引，只使用age和sex或只使用name和sex时索引失效。②在索引上进行运算或函数操作时索引失效。③数字字符没有加单引号索引失效，因为MySQL查询优化器会自动进行类型转换。④LIKE以%开头的查询索引失效，%在前时执行计划更倾向于使用全表扫描。⑤OR的前后没有同时使用索引时索引失效。⑥当全表扫描比使用索引速度更快时会使用全表扫描。

### Q10：简述数据库三大范式(最小数据单元,主键,非主键)

答：①第一范式：如果每列都是不可再分的最小数据单元，则满足第一范式。例如address：中国北京可拆分为两列，countyr：中国，city：北京。②第二范式：在第一范式的基础上，规定表中的非主键列不存在对主键的部分依赖，即第二范式要求每个表只描述一件事情。例如订单表：订单编号、产品编号、订单日期、产品价格可拆分为订单表：订单编号、订单日期和产品表：产品编号、产品价格。③第三范式：满足第一和第二范式，并且表中的列不存在对非主键列的传递依赖。例如订单表：订单编号、订单日期、用户编号、用户姓名可优化为订单表：订单编号、订单日期、用户姓名。

### ***Q11：MySQL数据库的隔离级别有哪些？分别有什么特点？

答：①未提交读，一个事务会读取到另一个事务没有提交的数据，存在脏读、不可重复读、幻读的问题。②已提交读，一个事务可以读取到另一个事务已经提交的数据，解决了幻读的问题，存在不可重复读、幻读的问题。③可重复读，MySQL默认的隔离级别，在一次事务中读取同一个数据结果是一样的，解决了不可重复读的问题，存在幻读问题。④可串行化，每次读都需要获得表级共享锁，读写互相阻塞，效率低，解决了幻读问题。

### Q12：读取数据库时可能出现哪些问题？

答：①脏读，一个事务中会读取到另一个事务中还没有提交的数据，如果另一事务最终回滚了数据，那么所读取到的数据就是无效的。②不可重复读，一个事务中可以读取到另一个事务中已经提交的数据，在同一次事务中对同一数据读取的结果可能不同。③幻读，一个事务在读取数据时，当另一个事务在表中插入了一些新数据时再次读取表时会多出几行，如同出现了幻觉。

### ***Q13：简述事务的ACID属性

答：①Atomicity表示原子性，事务中的所有操作都是不可分割的原子单位，要么全部成功，要么全部失败。②Consistency表示一致性，无论正常执行还是异常退出，事务执行前后数据的完整性必须保持一致，比如转账前后双方的总金额是不变的。(举个粒子，张三给李四转账100元。事务要做的是从张三账户上减掉100元，李四账户上加上100元。一致性的含义是其他事务要么看到张三还没有给李四转账的状态，要么张三已经成功转账给李四的状态，而对于张三少了100元，李四还没加上100元这个中间状态是不可见的。)③Isolation表示隔离性，并发操作中不同事务是互相隔离的，之间不会互相影响。④Durability表示持久性，事务操作完成后数据就会被持久化修改到永久存储中。

### ACID是如何实现的?

*Mysql怎么保证**原子性**的？*

利用Innodb的`undo log`。 `undo log`名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。

*Mysql怎么保证**持久性**的？*

OK，是利用Innodb的`redo log`。 正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。 *怎么解决这个问题？* 简单啊，事务提交前直接把数据写入磁盘就行啊。

*Mysql怎么保证**隔离性**的*

OK,利用的是锁和MVCC机制。至于MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在`undo log`中。 如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。

### Q14：简述主从复制的基本原理

答：①主从复制是指一台服务器充当主数据库服务器，另外一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器中。对于多级复制，数据库服务器既可充当主机也可充当从机。②MySQL主从复制的基础是主服务器对数据库修改二进制记录，从服务器通过主服务器的二进制日志自动执行更新。



### Q15：MySQL有哪些锁？

答：①按操作类型可以分为读锁（共享锁S）和写锁（排它锁X）。读锁：对同一份数据，多个读操作可以同时进行而不会互相影响。写锁：当前操作没有完成之前，会阻塞其他读锁和写锁。②按操作粒度分为行锁、表锁、页锁。行锁指对某行数据加锁，是一种排它锁。表锁指对当前操作的整张表加锁，实现简单，资源消耗较少。③页锁的锁定粒度介于行锁和表锁之间，一次锁定相邻的一组记录。

### Q16：视图是什么？和普通的表有什么区别？

答：①视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。②视图相对于普通的表的优势主要包括以下几项：简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。

### Q17：存储过程和函数是什么？有什么区别？

答：①存储过程和函数是 **事先经过编译并存储在数据库中的一段 SQL 语句的集合**，调用存储过程和函数可以简化**应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输**，对于提高数据处理的效率是有好处的。  ②**两者的区别在于函数必须有返回值，而存储过程没有返回值。**

### Q18：触发器是什么？

答：①触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。②使用别名 OLD 和NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。

### Q19：了解MySQL的体系结构吗？

答：**① 连接层：最上层是一些客户端和链接服务**，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。**②服务层：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。**所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。**③ 引擎层：存储引擎层，** 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。④存储层：数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。

### Q20：存储引擎应当怎样进行选择？

答：①在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。②InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。③MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。④MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。⑤MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。

### Q21：优化SQL的步骤了解吗？

答：

①查看SQL执行频率。

```mysql
show [session] status like 'Com_select';#查看select执行次数
Com_select
Com_insert
Com_update
Com_delete#查看增删改查的执行频率  Com针对的是所有存储引擎的表操作都会进行累计
#因此如果想要查找针对innodb就可以用innodb_rows_read
innodb_rows_inserted
innodb_rows_updated
innodb_rows_deleted
```

②定位低效率执行SQL。可以通过以下两种方式：

* 慢查询日志(slow_queries) : 通过**慢查询日志**定位那些执行效率较低的 SQL 语句。
* show processlist : **慢查询日志在查询结束以后才记录**，所以在应用反映执行效率出现问题的时候查询**慢查询日志并不能定位问题**，可以使用show processlist命令查**看当前MySQL在进行的线程**，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。

③通过以上步骤查询到效率低的 SQL 语句后，可以通过 **EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息**，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。

```mysql
explain select * from tb_name where id=1;
```

结果有10列 ; 

```
id:select 查询序列号,表示查询中执行select子句的顺序
select_type: 表示select的类型,常见的有simple(简单表),primary(主查寻),subquery(子查询)
table:输出结果集的表
type:表的连接类型
```

④Mysql从5.0.37版本开始增**加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里了。**

⑤MySQL5.6**提供了对SQL的跟踪trace**, 通过trace文件能够进一步了解为什么**优化器选择A计划, 而不是选择B计划。**打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。

###  *Q21：索引的原理

```
https://blog.csdn.net/weiliangliang111/article/details/51333169
```

索引是在**存储引擎中实现**的,不是在服务器层实现的.所以每种引擎的索引不一定相同.也不是所有的搜索引擎都支持索引.Mysql中一共支持4中索引,最常用的是BTREE索引,如果不加说明,默认是B+树结构组织的索引. 索引是在表的列上创建。所以，要记住的关键点是**索引包含一个表中列的值，并且这些值存储在一个数据结构中**。**请记住记住这一点：索引是一种数据结构 。**

事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐; 如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。
**每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 **因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。

**非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据. 不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。**然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。 文章上面的内容已经指出， 当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。

```
先看下面这个SQL语句
//建立索引
create index index_birthday on user_info(birthday);
//查询生日在1991年11月1日出生用户的用户名
select user_name from user_info where birthday = '1991-11-1'
这句SQL语句的执行过程如下
首先，通过非聚集索引index_birthday查找birthday等于1991-11-1的所有记录的主键ID值
然后，通过得到的主键ID值执行聚集索引查找，找到主键ID值对就的真实数据（数据行）存储的位置
最后， 从得到的真实数据中取得user_name字段的值返回， 也就是取得最终的结果
```

```
我们把birthday字段上的索引改成双字段的覆盖索引

create index index_birthday_and_user_name on user_info(birthday, user_name);

这句SQL语句的执行过程就会变为

通过非聚集索引index_birthday_and_user_name查找birthday等于1991-11-1的叶节点的内容，然而， 叶节点中除了有user_name表主键ID的值以外， user_name字段的值也在里面， 因此不需要通过主键ID值的查找数据行的真实所在，直接取得叶节点中user_name的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能.
```



### *Q22:如何选择索引

对于索引中的每一项，mysql在内部为它保存一个数据文件中实际记录所在位置的“指针”。因此，如果我们要查找name等于“Mike”记录的 peopleid（SQL命令为“SELECT peopleid FROM people WHERE name=’Mike’;”），**MySQL能够在name的索引中查找“Mike”值，然后直接转到数据文件中相应的行，准确地返回该行的 peopleid（999）。在这个过程中，MySQL只需处理一个行就可以返回结果。如果没有“name”列的索引，MySQL要扫描数据文件中的所有记录**，即1000个记录！显然，需要MySQL处理的记录数量越少，则它完成任务的速度就越快。

在性能优化过程中，选择在哪些列上创建索引是最重要的步骤之一。可以**考虑使用索引的主要有两种类型的列：在WHERE子句中出现的列，在join子句中出现的列**。请看下面这个查询：

SELECT age ## 不使用索引
FROM people WHERE firstname=’Mike’ ## 考虑使用索引
AND lastname=’Sullivan’ ## 考虑使用索引

这个查询与前面的查询略有不同，但仍属于简单查询。由于age是在SELECT部分被引用，MySQL不会用它来限制列选择操作。因此，对于这个查询来说，创建age列的索引没有什么必要。下面是一个更复杂的例子：

SELECT people.age, ##不使用索引
town.name ##不使用索引
FROM people LEFT JOIN town ON
people.townid=town.townid ##考虑使用索引
WHERE firstname=’Mike’ ##考虑使用索引
AND lastname=’Sullivan’ ##考虑使用索引

与前面的例子一样，由于firstname和lastname出现在WHERE子句中，因此这两个列仍旧有创建索引的必要。除此之外，**由于town表的townid列出现在join子句中，因此我们需要考虑创建该列的索引。**

那么，我们是否可以简单地认为应该索引WHERE子句和join子句中出现的每一个列呢？差不多如此，但并不完全。我们还必须考虑到对列进行比较的操作符类型。**MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE。可以在LIKE操作中使用索引的情形是指另一个操作数不是以通配符（%或者_）开头的情形。**例如，“SELECT peopleid FROM people WHERE firstname LIKE ‘Mich%’;”这个查询将使用索引，但“SELECT peopleid FROM people WHERE firstname LIKE ‘%ike’;”这个查询不会使用索引。


### *Q23:多个单列索引与联合索引

```
转:https://blog.csdn.net/Abysscarry/article/details/80792876
```

*我们是创建**多个单列索引**还是创建**一个联合索引**好呢？他们之间的区别是什么？哪个效率高呢？*

* 联合索引

我们为userId, mobile, billMonth三个字段添加上联合索引！

我们选择 explain 查看执行计划来观察索引利用情况：

1.查询条件为 userid

EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE userid='2222'
![这里写图片描述](https://img-blog.csdn.net/2018062415524243?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


可以通过key看到，联合索引有效

2.查询条件为 mobile

EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE mobile='13281899972'
![这里写图片描述](https://img-blog.csdn.net/20180624155746192?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

可以看到联合索引无效

3.查询条件为 billMonth

EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE billMonth='2018-04'
同上

联合索引无效

4.查询条件为 userid and mobile

EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE userid='2222' AND mobile='13281899972'
![这里写图片描述](https://img-blog.csdn.net/20180624160135826?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

联合索引有效

5.查询条件为 mobile and userid

EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  mobile='13281899972' AND userid='2222' 
![这里写图片描述](https://img-blog.csdn.net/20180624160251906?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

在4的基础上调换了查询条件的顺序，发现联合索引依旧有效

6.查询条件为 userid or mobile

EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE userid='2222' OR mobile='13281899972'
![这里写图片描述](https://img-blog.csdn.net/20180624161125355?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

把 and 换成 or，发现联合所索引无效！

7.查询条件为 userid and billMonth

EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE userid='2222' AND billMonth='2018-04'
![这里写图片描述](https://img-blog.csdn.net/20180624161421218?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

这两个条件分别位于联合索引位置的第一和第三，测试联合索引依旧有效！

8.查询条件为 mobile and billMonth

EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE mobile='13281899972' AND billMonth='2018-04'
![这里写图片描述](https://img-blog.csdn.net/20180624161555999?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

这两个条件分别位于联合索引位置的第二和第三，发现联合索引无效！

9.查询条件为 userid and mobile and billMonth

EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid='2222' AND mobile='13281899972' AND billMonth='2018-04'
![这里写图片描述](https://img-blog.csdn.net/20180624162525113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

所有条件一起查询，联合索引有效！（当然，这才是最正统的用法啊！）

```
总结:
1.采用最左前缀原则.如果查询的字段里面没有最左边的索引时(这里是userid),索引失效
2.查询语句中,最左索引的位置可以变化(不在第一个位置),mysql执行优化器会对其进行优化,索引仍然是有效的
3.联合索引的本质是:当创建(a,b,c)联合索引时，相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引,想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！
```

* 单列索引

*创建三个单列索引：*

**1.查询条件为 `userid and mobile and billMonth`**

```mysql
EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid='2222' AND mobile='13281899972' AND billMonth='2018-04'
```

![这里写图片描述](https://img-blog.csdn.net/20180624163500567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

我们发现三个单列索引**只有 `userid` 有效（位置为查询条件第一个）**，其他两个都没有用上。

其实这里其实涉及到了**mysql优化器的优化策略！**当多条件联合查询时，**优化器会评估用哪个条件的索引效率最高！**它会选择最佳的索引去使用，也就是说，此处userid 、mobile 、billMonth这三个索引列都能用，只不过优化器**判断只需要使用userid这一个索引就能完成本次查询，故最终explain展示的key为userid。**

当然，如果优化器判断本次查询非要全使用三个索引才能效率最高，那么explain的key就会是userid 、mobile 、billMonth，都会生效！

**3.查询条件为 `userid or mobile`**

```
EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid='2222' OR mobile='13281899972' 
```

![这里写图片描述](https://img-blog.csdn.net/2018062416412814?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FieXNzY2Fycnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

这次把 `and` 换成 `or`，发现两个查询条件都用上索引了！

关于or查询的真相是：
所谓的索引失效指的是：**假如or连接的俩个查询条件字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描。**我们从or的基本含义出发应该能理解并认可这种说法，没啥问题。

此刻需要注意**type类型为index_merge。**
我查资料说mysql 5.0 版本之前 使用or只会用到一个索引（即使如上我给userid和mobile都建立的单列索引），但自**从5.0版本开始引入了index_merge索引合并优化！**也就是说，我们现在可以利用上**多个索引去优化or查询**了。

**index_merge作用：**
1、索引合并是把几个索引的范围扫描合并成一个索引。
2、索引合并的时候，会对索引进行并集，交集或者先交集再并集操作，以便合并成一个索引。
3、这些需要合并的索引只能是一个表的。不能对多表进行索引合并。

index_merge应用场景：

1.对OR语句求并集，如查询SELECT * FROM TB1 WHERE c1="xxx" OR c2=""xxx"时，如果c1和c2列上分别有索引，可以**按照c1和c2条件进行查询**，再**将查询结果合并（union）操作**，得到最终结果

2.对AND语句求交集，如查询SELECT * FROM TB1 WHERE c1="xxx" AND c2=""xxx"时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果取交集（intersect）操作，得到最终结果

3.对AND和OR组合语句求结果

```
多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上！ 但多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费一定搜索效率，故如果只有多条件联合查询时最好建联合索引！

同时存在联合索引和单列索引（字段有重复的），这个时候查询mysql会怎么用索引呢？
这个涉及到mysql本身的查询优化器策略了，当一个表有多条索引可走时, Mysql 根据查询语句的成本来选择走哪条索引；
```

**联合索引比对每个列分别建索引更有优势**，因为索引建立得越多就越占磁盘空间，在更新数据的时候速度会更慢。另外建立多列索引时，顺序也是需要注意的，**应该将严格的索引放在前面，这样筛选的力度会更大，效率更高**。



### ***Q24:聚集索引与非聚集索引

```
https://blog.csdn.net/qq_29373285/article/details/85254407
```

**1.聚集（clustered）索引，也叫聚簇索引**

定义：数据行的**物理顺序**与列值（一般是主键的那一列）的**逻辑顺序**相同，一个表中只能拥有一个聚集索引。(SQL server默认主键是聚集索引,而mysql的主键是聚集索引)

**2.非聚集（unclustered）索引**

定义：该索引中索引的***\*逻辑顺序与磁盘上行的物理存储顺序不同\****，一个表中可以拥有多个非聚集索引。

索引的**叶子节点就是对应的数据节点**（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行**二次查询**

**3.非聚集索引的二次查询问题**

非聚集索引**叶节点**仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行**第二次的查询**，查询节点上对应的数据行的数据。

<img src="https://img-blog.csdnimg.cn/20181225211503873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MzczMjg1,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

其中有 聚集索引clustered index(id), 非聚集索引index(username)。

建立的聚集索引的结构是这样的:首先提取出username列与主键id列,构建非聚集索引数据结构.然后如果只是查询id或者username是可以直接从非聚集索引中查到的,但是如果要查询非聚集索引中没有的字段score,则必须先根据这个主键id定位到聚集索引,因为聚集索引中有全部的数据.

### *Q26:索引的分类

* 按物理地址划分:
  * 聚集索引
  * 非聚集索引

聚集索引

表记录的排列顺序和索引的排列顺序一致,所以查询效率快,只要找到第一个索引值记录,其余连续性的记录在物理上一样连续存放.聚集索引的缺点就是修改慢,因为为了使表记录和索引的排列顺序一致,在插入记录的时候,会对数据页重新排序

非聚集索引

表记录和索引的排列顺序不一定一致,两种索引都采用B+树的结构,非聚集索引的叶子层并不和实际数据页相重叠,而采用叶子层包含一个指向表记录的指针.非聚集索引层次多,不会造成数据重排



### *Q27覆盖索引



### ***Q28 B树B+树

1）B树

B树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。

成功搜索包括节点内搜索和沿某一路径的搜索，成功搜索时间取决于关键码所在的层次以及节点内关键码的数量。

在B树中查找给定关键字的方法是：首先把根结点取来，在根结点所包含的关键字K1,…,kj查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查的关键字在某个Ki或Ki+1之间，于是取Pi所指的下一层索引节点块继续查找，直到找到，或指针Pi为空时查找失败。

2）B+树
B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非也节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。如果实际数据对象按加入的顺序存储而不是按关键码次数存储的话，叶节点的索引必须是稠密索引，若实际数据存储按关键码次序存放的话，叶节点索引时稀疏索引。

B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。

所以 B+树有两种搜索方法：

一种是按叶节点自己拉起的链表顺序搜索。

一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。

B+ 树中，数据对象的插入和删除仅在叶节点上进行。

这两种处理索引的数据结构的不同之处：

```
a，B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。
b，因为B树键位置不定，且在整个树结构中只出现一次，虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。
c，B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。
```

### 设置超级权限用户

```mysql
mysql>GRANT ALL PRIVILEGES ON *.* TO username@localhost IDENTIFIED BY 'password' WITH GRANT OPTION;
##  privilege  Recognized
```



### ***哈希索引与B+树索引

 **Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位**，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 **Hash 索引的查询效率要远高于 B-Tree 索引。**

**哈希索引的缺点:**

```
1).Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
    由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。
2).Hash 索引无法被用来避免数据的排序操作。
    由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；
3).Hash 索引不能利用部分索引键查询。
    对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
4).Hash 索引在任何时候都不能避免表扫描。
    前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
5).Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。
    对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下
    
总结的关键字:只能完成部分搜索,不能完成范围查询;无法排序;不能按照部分索引来查询;不能避免全表扫面(加挂的桶需要挨个去扫描);哈希冲突比较多时候性能差于B+树.
```

**Hash索引与B+树的区别**

```
 1).如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
2).从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
3).同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
4).哈希索引也不支持多列联合索引的最左匹配规则；
5).B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

总结的区别就是哈希的弱点:

```

### mysql是怎么保证一致性的?

InnoDB存储引擎架构,要关注“Redo Log”(重做日志)和“Undo Tablespaces”(撤销列表)这两个区域;Undo Log是撤消日志记录的集合，其中包含如何撤消事务对聚集索引记录的最新更改的信息。

MySQL事务的四个特性中**ACD三个特性是通过Redo Log（重做日志）和Undo Log 实现的，而 I（隔离性）是通过Lock（锁）来实现。**

```
https://zhuanlan.zhihu.com/p/90187667
```

### ***drop> truncate > delete

1. 语言种类不同
   * drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。
   * delete是DML语句 , 这个操作会放到 rollback segement 中，事务提交之后才生效. 
2. 删除的内容不同
   * **truncate 和 delete 只删除数据不删除表的结构**(定义)
   * drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。
3. 是否可回滚
   * **delete可回滚, 这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。**
   * **truncate、drop 是数据库定义语言(ddl)，操作立即生效**，**原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。**
4. **速度，一般来说: drop> truncate > delete** , TRUNCATE  TABLE  在功能上与不带  WHERE  子句的  DELETE  语句相同：**二者均删除表中的全部行**。但  TRUNCATE  TABLE  比  DELETE  速度快，且使用的系统和事务日志资源少。**DELETE  语句每次删除一行，并在事务日志中为所删除的每行记录一项。**TRUNCATE  TABLE  通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 
5. TRUNCATE  TABLE  删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用  DELETE。如果要删除表定义及其数据，请使用  DROP  TABLE  语句。 对于由  FOREIGN  KEY  约束引用的表，不能使用  TRUNCATE  TABLE，而应使用不带  WHERE  子句的  DELETE  语句。由于  TRUNCATE  TABLE  不记录在日志中，所以它不能激活触发器。 TRUNCATE  TABLE  不能用于参与了索引视图的表。 
6. 安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及
   使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大.
   想删除表,当然用 drop . 想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。

https://www.cnblogs.com/8765h/archive/2011/11/25/2374167.html

### ***数据库语句

DDL:

DML:

https://www.jianshu.com/p/49fcde3e4559

* 数据插入

  ```mysql
  #按顺序依次添加
  insert into tb_name values('G',...);
  #插入指定列的数据
  insert into tb_name () values ();
  ```

* 数据更新/数据修改

  ```mysql
  update tb_name set name='l' where name='z';
  ```

* 属性修改

  ```mysql
  #添加列
  alter table tb_name add column col_name Enum('1','0') not null default '1';
  # 添加唯一約束
  1) ALTER TABLE tb_name ADD UNIQUE (name);
  2) CREATE UNIQUE INDEX [索引名称] ON tb_name(tb_field);
  # 更改列属性
  ALTER TABLE tb_name MODIFY COLUMN tb_field VARCHAR(50);
  # 更改列名
  ALTER TABLE tb_name RNAME COLUMN tb_fieldA to tb_fieldB;
  ALTER TABLE tb_name CHANGE tb_fieldA tb_fieldB varchar(255);
  ```

* 删除数据

  ```mysql
  #删除一个记录
  delete from tb_name where name='bill';
  #删除所有行
  delete from tb_name;
  #删除表
  drop table tb_name;
  #删除数据库
  drop database db_name;
  #删除索引
  alter table tb_name drop index [索引名称];
  #删除列
  alter table tb_name drop column col_name;
  ```

  

### limit用法

**limit表示分页查看**

https://blog.csdn.net/lanyang123456/article/details/57522471

* 如果只给定一个参数，表示记录数。

  ```mysql
  mysql> SELECT * FROM orange LIMIT 5;     //检索前5条记录(1-5)
  ```

  相当于`mysql> SELECT * from orange LIMIT 0,5;`  0其实代表的是从1开始

* 如果给定两个数, 一个表示偏移量, 一个表示记录数

  ```mysql
  mysql> SELECT * FROM orange LIMIT 10,15;  // 检索记录11-25
  ```

* 如果用offset, 则一个limit后面的表示的是记录数, offset后面的是偏移量

  ```mysql
  mysql> SELECT * FROM orange LIMIT 2 OFFSET 3;//查询4-5两条记录
  ```

  等价于`mysql> SELECT * FROM orange  LIMIT 3,2;`

**mysql order by limit 的一个坑**

对单个无索引的字段进行排序后limit .发现当被排序字段有相同值时并且在limit范围内，取的值并不是正常排序后的值，也就是说，当排在第N行的数据可取key1、 key2 时 ， 排序结果可能是key1，也可能是key2。

`select * from cnt_table  order by cnt desc`

<img src="https://img-blog.csdn.net/20180608184904451?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R5NTU1dHk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

排序+ limit 结果 （排序键无索引）
按cnt取key_word分别前三结果：

>select * from cnt_table  order by cnt desc limit 1 
>
>select * from cnt_table  order by cnt desc limit 1, 1 
>
>select * from cnt_table  order by cnt desc limit 2, 1

```mysql
            key_word    cnt
结果  ：       333       1
              222       1
              333       1
```

**这是mysql对limit的优化。如果order by的列有相同的值时， mysql会随机选取这些行，具体根据执行计划有所不同。**

解决： **order by 的列中包含一个索引列**
**此处增加主键id为排序列**

>select * from cnt_table  order by cnt desc,id asc limit 1; 
>
>select * from cnt_table  order by cnt desc,id asc limit 1,1; 
>
>select * from cnt_table  order by cnt desc,id asc limit 2,1;

<img src="https://img-blog.csdn.net/20180611161213961?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R5NTU1dHk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom: 80%;" />

### 锁的类型

mysql锁分为**共享锁**和**排他锁**，也叫做读锁和写锁。

* 读锁是共享的，可以通过lock in share mode实现，这时候**只能读不能写。**共享锁可以同时加上多个。

* 写锁是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为**表锁**和**行锁**两种。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。
* **读锁会阻塞写，写锁会阻塞读和写**，MyISAM不适合做写为主表的引擎，因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。

按粒度分为**行级锁和表级锁和页级锁**

* 表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比**如alter修改表结构的时候会锁表。**

* **行级锁** 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。

  **特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也**最高。

  **表级锁** 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它**实现简单，资源消耗较少**，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

  特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，**并发度最低。**

  **页级锁** 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

  特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

  

### 隔离级别与锁的关系

* 在Read Uncommitted级别下，**读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突**

* 在Read Committed级别下，**读操作需要加共享锁，但是在语句执行完以后释放共享锁；**

* 在Repeatable Read级别下，**读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。**

* SERIALIZABLE 是限制性最强的隔离级别，因为该级别**锁定整个范围的键**，并一直持有锁，直到事务完成。



### 行锁表锁的实现

**MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁**，这个过程并不需要用户干预。**innodb会自动给通过索引查询的行上加行锁，如果不走索引，则会走表锁。**

**MyISAM：**

因此用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。**MyISAM存储引擎不适合大量的更新操作和查询操作，因为查询操作获取读锁的优先级比较低**

**显式加锁：**
上共享锁（读锁）的写法：**lock in share mode**，例如：

```sql
select  math from zje where math>60 lock in share mode；
```

上排它锁（写锁）的写法：**for update**，例如：

```sql
select math from zje where math >60 for update；
```

**InnoDB**

InnoDB是基于索引来完成行锁

例: select * from tab_with_index where id = 1 **for update;**

for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起。**行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁，此时其它事务无法对当前表进行更新或插入操作。**

**行锁的实现需要注意：**

- 行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。

- 两个事务不能锁同一个索引。由于InnoDB的行锁实现是针对索引字段添加的锁，不是针对行记录加的锁，因此虽然访问的是InnoDB引擎下表的不同行，**但是如果使用相同的索引字段作为过滤条件，依然会发生锁冲突**，只能串行进行，不能并发进行。

- **insert，delete，update在事务中都会自动默认加上排它锁。**

  行锁场景：

  **查询转账时候-->加for update避免查到账户够的情况下被B账户转走,余额又不足的情况.**

  A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询的时候应该对该记录进行加锁。

  否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。

  为了避免此情况，需要在A用户操作该记录的时候进行for update加锁

**InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁**。

**两阶段锁协议：**在InnoDB事物中，**行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事物提交了才会释放，这个就是两阶段锁协议；**

知道了这个协议后，对我们的某些开发会得到效率提升，比如：

- 如果你的事物中需要锁多个行，**要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放**；



### **间隙锁**

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内并不存在的记录，叫做间隙(Next-Key锁)。

InnoDB也会对这个"间隙"加锁，这种锁机制就是所谓的间隙锁

```sql
-- 用户A
update user set count=8 where id>2 and id<6

-- 用户B
update user set count=10 where id=5;
12345
```

如果用户A在进行了上述操作后，事务还未提交，则B无法对2~6之间的记录进行更新或插入记录，会阻塞，当A将事务提交后，B的更新操作会执行。



### InnoDB死锁

MyISAM 表锁是 deadlock free 的， 这是因为 MyISAM 总是一次获得所需的全部锁，要么全部满足，要么等待，**因此不会出现死锁**。但在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，即锁的粒度比较小，这就决定了在 InnoDB 中发生死锁是可能的。

### 死锁检测策略

（1）：**直接进入等待，直到超时**，这个超时时间可以通过参数innodb_lock_wait_timeout来进行设置，如下：（InnoDB中查看这个参数**默认是50秒**）

```mysql
mysql> set innodb_lock_wait_timeout = 50;
Query OK, 0 rows affected (0.00 sec)
```

（**2）发起死锁检测**，发现死锁后，主动回滚死锁链条中的某一个事物，让其他事物得以执行；
将参数**innodb_deadlock_detect**设置为on，就代表开启； （InnoDB默认开启死锁检测）

**发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。**

两种方案区别：

- 第一种等待50s，这显然对于在线服务起来说是等不起的，时间设置太短又会造成误判；
- 所以一般采用第二种：死锁检测，InnoDB本身默认就是将那个参数设置为on的，但这种方式也是有弊端的，毕竟死锁检测需要消耗资源，具体详细下面来讲；

### 死锁检测（⭐）

上面讲了，死锁检测是数据库检验死锁的一个策略，**检测所需要的代价就是：**

- 每当一个事物被锁住的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，即死锁；

**进行死锁检测的条件：**

- 当前事物需要加锁访问的行上被别人锁住时，才会进行死锁检测

**注意点：**

- 一致性读的时候不会加锁，所以不用死锁检测
- 并不是每次死锁检测都要扫描所有的事物，**比如下面这种情况：**
  B在等A
  D在等C
  现在事物E来了，发现E需要等D，则此时E需要判断跟D、C是否成环（形成死锁），并不会去检测B和A，因为他们访问的肯定不是同一个资源；

### 死锁怎么解决？

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法

1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁



### **数据库的乐观锁和悲观锁是什么？怎么实现的？

行锁又可以分为**乐观锁**和**悲观锁**，**悲观锁可以通过for update实现，乐观锁则通过版本号实现。**

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

**悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制

**乐观锁**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：**一般会使用版本号机制或CAS算法实现。**乐观锁，使用版本标识来确定读到的数据与提交时的数据是否一致。**提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。** CAS操作包含三个操作数，内存位置（V）,预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会西东将该位置值更新为新值。否则，处理器不做任何操作。

**两种锁的使用场景**

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**



### **多版本数据库MVCC**

MVCC（Multi-Version Concurrency Control，多版本并发控制）一种并发控制机制，在数据库中**用来控制并发执行的事务，控制事务隔离进行**。MVCC是通过**保存数据在某个时间点的快照来进行控制的**。使用MVCC就是**允许同一个数据记录拥有多个不同的版本**。然后在查询时通过添加相对应的约束条件，就可以获取用户想要的对应版本的数据。

多版本的并发控制**(MVCC)相对于传统的基于锁的并发控制主要特点是读不上锁**，这种特性对于读多写少的场景，大大提高了系统的并发度，因此大部分关系型数据库都实现了MVCC。大家都应该知道,锁机制可以控制并发操作,但是其系统开销较大,而**MVCC可以在大多数情况下代替行级锁,**使用MVCC,能降低其系统开销.



### **关系型数据库与非关系型数据库

#### 关系型数据库：mysql-oracle-sql-server

关系型数据库是一种表结构，由二维表和数据之间的联系组成

**优点：**
1、**易于维护**：都是使用表结构，**格式一致**；
2、**使用方便**：**SQL语言通用**，可用于复杂查询；
3、**复杂操作**：**支持SQL**，可用于一个表以及多个表之间非常复杂的查询。
**缺点：**
1、**读写性能比较差**，尤其是海量数据的高效率读写；
2、固定的表结构，**灵活度稍欠**；
3、高并发读写需求，传统关系型数据库来说，**硬盘I/O是一个很大的瓶颈**。

#### 非关系型数据库：redis



## **计算机网络** **7** 

### Q1：说一说OSI网络模型

答：网络的七层架构从下到上主要包括物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。**①物理层**：物理层主要定义物理设备标准，主要作用是**传输比特流，具体做法是在发送端将1、0转化为电流强弱来进行传输，在到达目的地之后再将电流强弱转化为1、0，也就是我们常说的模数转换与数模转换，这一层的数据叫做比特**。**②数据链路层**：数据链路层主要用**于对数据包中的MAC地址进行解析和封装**。这一层的数据叫做帧，在这一层工作的**设备是网卡、网桥、交换机**。**③网络层：**网络层主要用于对数据包中**的IP地址进行封装和解析，**这一层的数据叫做数据包。在这一层工作的设备有路由器、交换机、防火墙等。**④传输层**：传输层定义了传输数据的协议和端口号，主要用于数据的分段、传输和重组。在这一层工作的协议有TCP和UDP等。TCP是传输控制协议，传输效率低，可靠性强，用于传输对可靠性要求高，数据量大的数据，比如支付宝转账业务；UDP是用户数据报协议，用于传输可靠性要求不高，数据量小的数据，例如抖音等视频服务。**⑤会话层**：会话层在传输层的基础上**建立连接和管理会话，具体包括登陆验证、断点续传、数据粘包与分包等**。在设备之间需要互相识别的可以是IP，也可以是MAC或者主机名。**⑥表示层**：表示层主要**对接收的数据进行解释、加密、解密、压缩、解压缩等，即把计算机能够识别的内容转换成人能够识别的内容（图片、声音、文字等）**。**⑦应用层**：基于网络构建具体应用，例如FTP上传文件下载服务、Telnet服务、HTTP服务、DNS服务、SNMP邮件服务等。

### 应用层协议:

应用层协议是多种多样的，比如 DNS、FTP、Telnet、SMTP、HTTP、RIP、NFS 等协议都是用于解决其各自的一类问题。

1. **DNS**

DNS (Domain Name Service 域名服务) **协议基于 UDP**，使用**端口号 53。**

由数字组成的 IP 地址很难记忆，所以我们上网使用网站 IP 地址的别名——域名。实际使用中，域名与 IP 地址是对应的，这种对应关系保存在**DNS 服务器**之中。

2. **FTP**

FTP (File Transfer Protocol 文件传输协议) **基于 TCP**，使用**端口号 20(数据)和 21(控制)。**

它的主要功能是**减少或消除在不同操作系统下处理文件的不兼容性**，以达到便捷高效的文件传输效果。

- FTP **只提供文件传输的基本服务，它采用 客户端—服务器 的方式，一个 FTP 服务器可同时为多个客户端提供服务。**
- 在进行文件传输时，FTP 的客户端和服务器之间会建立两个 TCP 连接：21 号端口建立**控制连接**，20 号端口建立**数据连接**。
- **FTP 的传输有两种方式：ASCII 传输模式和二进制数据传输模式。**

3. **http**

HTTP (HyperText Transfer Protocol 超文本传输协议) **基于 TCP**，使用**端口号 80** 或 8080。

每当你在浏览器里输入一个网址或点击一个链接时，浏览器就通过 HTTP 协议将网页信息从服务器提取再显示出来，这是现在使用频率最大的应用层协议。

这个原理很简单：

- 点击一个链接后，浏览器向服务器发起 TCP 连接；
- 连接建立后浏览器**发送 HTTP 请求报文，然后服务器回复响应报文；**
- **浏览器将收到的响应报文内容显示在网页上；**
- 报文收发结束，关闭 TCP 连接。



### 为什么DNS协议是基于UDP协议的?

以浏览器为例，计算机通信的这个响应时间大体分为三部分：

```
响应时间= DNS域名解析时间+ TCP连接建立时间 + HTTP交易时间
```

如果让响应时间尽可能小，只有让等号右侧的三者尽可能小。

- TCP连接是固定的三次握手，所以很难有进一步缩小的空间。
- HTTP交易，基于Request / Response，也很难有提升的空间。

所以，只能让DNS域名解析的时间越小越好。

**采用TCP传输，则域名解析时间为**：
 `DNS域名解析时间 = TCP连接时间 + DNS交易时间`

**采用UDP传输，则域名解析时间为**：
 `DNS域名解析时间 = DNS交易时间`

很显然，采用UDP传输，DNS域名解析时间更小。由于域名解析并不是一次就可以完成,因此这个开销并不小.

**UDP传输的弱点:**

由于历史的原因，互联网上物理链路的最小MTU = 576，基于UDP传输的DNS为了限制报文不超过576，所以将DNS报文限制在512字节.**这样一旦DNS查询应答超过512字节，基于UDP的DNS就只有截短为512字节，那么用户得到的DNS应答就是不完整的。**为了克服这种困难，**最简单的方式就是使用TCP，来重新查询。**尽管交易时间可能比较长，但毕竟可以得到完整的答案 .**DNS没有字段来标识报文ID，比如1、2、3，所以默认只有一个报文，剩下的多余数据只有被扔的份！**,因此如果可以给报文编号,就可以传输超过576字节的报文了.

### Q2：说一说TCP/IP的网络模型

答：TCP/IP不是指TCP和IP这两个协议的合称，而是指因特网的整个TCP/IP协议簇。从协议分层模型方面来讲，TCP/IP由4个层次组成：**网络接口层、网络层、传输层和应用层**。**①网络接口层：**定义了**主机间网络连通的协议**，具体包括Echernet、FDDI、ATM等通信协议。**②网络层**：主要用于数据的传输、路由及地址的解析，以保障主机可以把数据发送给任何网络上的目标。数据经过网络传输，发送的顺序和到达的顺序可能发生变化。在网络层使用IP协议和ARP地址解析协议。**③传输层**：使源端和目的端的机器上的对等实体可以基于会话相互通信。在这一层定义了两个端到端的协议TCP和UDP。TCP是面向连接的协议，提供可靠的报文传输和对上层应用的连接服务，除了基本的数据传输，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP是面向无连接的不可靠传输的协议，主要用于不需要TCP的排序和流量控制等功能的应用程序。**④应用层：**负责具体**应用层协议的定义**，包括Telnet虚拟终端协议、**FTP文件传输协议**、SMTP简单电子邮件传输协议、**DNS域名解析服务**、NNTP网上新闻传输协议和HTTP超文本传输协议等。

### TCP三次握手与四次挥手

```
https://blog.csdn.net/lengxiao1993/article/details/82771768
```

<img src="https://img-blog.csdn.net/20180208112533496" alt="img" style="zoom:67%;" />

#### TCP 数据包结构图

![TCP包结构图](https://img-blog.csdn.net/2018091917061915?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

TCP报文段的数据包至少有20字节,最多不超过6字节(每个报文段都有报文首部以及对应的数据部分)

可以看到这里有几个大写的标志位:ACK-SYN-FIN标志位置1表示确认.

还有序号的信息(sequence,为小写seq)

| 源端口和目的端口，各占2个字节，分别写入源端口和目的端口；    |
| ------------------------------------------------------------ |
| 序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始； |
| 确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701； |
| 数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远； |
| 保留，占6位，保留今后使用，但目前应都位0；                   |
| 紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据； |
| 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1； |
| 送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1； |
| 复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接； |
| 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1； |
| 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放； |
| 窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受； |
| 检验和，占2字节，校验首部和数据这两部分；                    |
| 紧急指针，占2字节，指出本报文段中的紧急数据的字节数；        |
| 选项，长度可变，定义一些其他的可选的参数。                   |

### Q3：简述TCP的三次握手过程，为什么不是两次或四次？

答：①服务端创建传输控制块TCB，进入LISTEN状态，准备接收客户端的请求。客户端同样先创建TCB，然后当准备建立连接时向服务端发送连接请求报文（SYN=1，seq=x），然后进入SYN-SENT状态。②服务端收到后向客户端发送确认报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN-RCVD状态。③客户端接收到确认后，再向服务端发送一个确认报文（ACK=1，ack=y+1，seq=x+1），然后进入ESTABLISHED状态，服务端接收后也进入ESTABLISHED状态。

④不是两次的原因是为了避免无效的连接请求突然发送到服务端，而此时客户端已关闭，服务端误以为客户端将要发送数据会白白浪费资源。⑤不是四次的原因是将服务端的SYN和ACK报文拆分成两次发送和一次的效果是相同的，没有意义。

### 为什么需要三次握手，而非两次

#### 说法1:是为了客户端和服务端都可以确认对方知道了自己想要的seq序列号

正如上文所描述的，为了实现可靠传输，发送方和接收方始终需要同步( **SYN**chronize )序号。 需要注意的是， 序号并不是从 0 开始的， 而是由发送方随机选择的初始序列号 ( Initial Sequence Number, ISN )开始 。 由于 TCP 是一个双向通信协议， 通信双方都有能力发送信息， 并接收响应。 因此， 通信双方都需要随机产生一个初始的序列号， 并且把这个起始值告诉对方。(双方都有可能成为发送方,因此必须双方都得放松一个序列号)

![image-20200802203434574](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200802203434574.png)

下面的图比第一幅图清晰: **这里的seq的值是发送方发出的,ack的值是期望从接收方接受的报文段的序号.**

<img src="C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200802203825727.png" alt="image-20200802203825727" style="zoom:50%;" />

<img src="C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200802203835130.png" alt="image-20200802203835130" style="zoom:50%;" />

acknowledgement number **的作用是向对方表示，我期待收到的下一个序号。** 如果你向对方回复**了 ack = 31, 代表着你已经收到了序号截止到30的数据，期待的下一个数据起点是 31 ;**

TCP 协议规定**SYN报文虽然不携带数据， 但是也要消耗1个序列号**， 所以前两次握手客户端和服务端都需要向对方回复 x+1 或 y+1 。

#### 说法2:防止已失效的连接请求又传送到服务器端，因而产生错误

> 一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
>
> 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。
>
> 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。



### 三次握手可以携带数据吗?

![image-20200924144307512](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200924144307512.png)

### SYN攻击

https://segmentfault.com/a/1190000020610336

![image-20200924144412899](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200924144412899.png)



### Q4：简述TCP的四次挥手过程，为什么不是三次？

答：①当客户端准备关闭连接时，向服务端发送连接终止报文（FIN=1，seq=u），进入FIN-WAIT-1状态。②服务端接收后向客户端发送确认报文（ACK=1，ack=u+1，seq=v），进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态，此时TCP连接处于半关闭状态。③当服务端也发送完全部数据准备断开连接时，向客户发送连接终止报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST-ACK状态。④客户端接收到该报文后，发送一个确认报文（ACK=w+1，ack=1，seq=u+1），进入TIME-WAIT状态，然后等待2MSL时间后关闭。服务端收到后关闭，时间将略早于客户端。⑤不是三次的原因第一是为了保证客户端发送的最后一个报文可以到达服务端，如果该报文丢失那么服务端会超时重传之前的FIN+ACK报文，客户端可以在2MSL内收到，第二是防止已失效的报文发送到客户端，在2MSL后客户端在本连接时间内发出的所有报文都将从网络中消失。

关闭连接时候--服务端接收到fin信号后,不是马上发送ack+fin信号,而是等到它的待发送的数据发送完成之后才会去发送一个fin信号,因此这里会有2次发送的过程.

### 四次挥手过程

```
https://blog.csdn.net/qzcsu/article/details/72861891
```

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

   ```
   解释的超级清楚:
   关于一些客户端和服务器的一些状态
   客户端发送完FIN后进入FIN-WAIT-1（终止等待1）状态->服务器接收到这个FIN后发送ACK,自己进入CLOSE-WAIT（关闭等待）状态->客户端接收到ACK后进入FIN-WAIT-2（终止等待2）状态->服务端发送完数据后再次发送FIN后进入LAST-ACK（最后确认）状态->客户端接收到这个FIN后最后发送一个ACK后进入TIME-WAIT（时间等待）状态,服务器接收到这个ACK立即进入CLOSED状态。而客户端的TIME-WAIT（时间等待）状态维持2∗*∗MSL（最长报文段寿命）的时间后如果期间没有收到服务端的信号后进入CLOSED状态。
   ```

   ![image.png](https://segmentfault.com/img/remote/1460000020610341)



### 客户端等待2msl的意义

msl是一个报文段在网络中最大的生存时间 . 这个时间段可以保证如果客户端发送的ACK没有被服务端接收到的话, 服务端重发的fin+ack信号可以在客户端断开连接之前接收到, 然后重新发送ack .可以防止TCP最后发送的ACK丢失. 这个2msl等待的结果是这个tcp连接在这等待的2msl时间里,定义这个连接的插口(客户的Ip地址和端口号,服务器的Ip地址和端口号) 不能再被使用 .这个连接只能在2msl结束之后才能再次被使用 . 

![image-20200924115143430](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200924115143430.png)

### 半连接队列

![image-20200924144015919](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200924144015919.png)



### 初始序列号是固定的吗?

![image-20200924144204780](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200924144204780.png)





### Q5：简述HTTP的传输流程

答：①地址解析：**地址解析通过域名系统DNS解析服务器域名从而获得主机的IP地址**。例如客户端的浏览器请求http://localhost:8080/index.html，则可分析出：协议名HTTP、主机名localhost、端口8080、对象路径/index.html。②**封装HTTP数据包：解析协议名、主机名、端口、对象路径等并结合本机自己的信息封装成一个HTTP请求数据包**。③**封装TCP包：将HTTP请求数据包进一步封装成TCP数据包**。④**建立TCP连接**：基于TCP的三次握手机制建立TCP连接。⑤**客户端发送请求**：在建立连接后，客户端发送一个请求给服务器。⑥服**务器响应：服务器在接收到请求后，结合业务逻辑进行数据处理，然后向客户端返回相应的响应信息**。在响应信息中包含状态行、协议版本号、成功或错误的代码、消息体等内容。⑦**服务器关闭TCP连接**：服务器在向浏览器发送请求响应数据后关闭TCP连接。但如果浏览器或者服务**器在消息头加入了Connection:keep-alive**，则TCP连接在请求响应数据后仍然保持连接状态，**在下一次请求中浏览器可以继续使用相同的连接发送请求**。采用keep-alive不但**减少了请求响应的时间，还节约了网络带宽和系统资源。**

### http请求/返回报文格式

```
https://blog.csdn.net/a19881029/article/details/14002273?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param
```

#### http请求报文格式

HTTP请求报文主要由请求行、请求头部、请求正文3部分组成

![img](https://img-blog.csdn.net/20131107150723906)

**1，请求行**

**由3部分组成，分别为：请求方法、URL（见备注1）以及协议版本，之间由空格分隔**

请求方法包括GET、HEAD、PUT、POST、TRACE、OPTIONS、DELETE以及扩展方法，当然**并不是所有的服务器都实现了所有的方法**，部分方法即便支持，处于安全性的考虑也是不可用的

协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1

**2，请求头部**

请求头部为请求报文添加了一些附加信息，**由“名/值”对组成，每行一对，名和值之间使用冒号分隔**

常见请求头如下：

| ***\*请求头\****    | ***\*说明\****                                      |
| ------------------- | --------------------------------------------------- |
| **Host**            | 接受请求的服务器地址，可以是IP:端口号，也可以是域名 |
| **User-Agent**      | 发送请求的应用程序名称                              |
| **Connection**      | 指定与连接相关的属性，如Connection:Keep-Alive       |
| **Accept-Charset**  | 通知服务端可以发送的编码格式                        |
| **Accept-Encoding** | 通知服务端可以发送的数据压缩格式                    |
| **Accept-Language** | 通知服务端可以发送的语言                            |

**请求头部的最后会有一个空行，表示请求头部结束，接下来为请求正文，这一行非常重要，必不可少**

**3，请求正文**

**可选部分，比如GET请求就没有请求正文**

GET请求示例：

![img](https://img-blog.csdn.net/20150626141001870?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

POST请求示例：

![img](https://img-blog.csdn.net/20150626150818159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

 

#### **http响应报文格式:**

HTTP响应报文主要由**状态行、响应头部、响应正文3部分组成**

![img](https://img-blog.csdn.net/20131107163544468)

**1，状态行**

**由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔**

状态代码为3位数字，200~299的状态码表示成功，300~399的状态码指资源重定向，400~499的状态码指客户端请求出错，500~599的状态码指服务端出错（HTTP/1.1向协议中引入了信息性状态码，范围为100~199）

**2，响应头部**

与请求头部类似，为响应报文添加了一些附加信息

常见响应头部如下：

| **响应头**           | ***\*说明\****                           |
| -------------------- | ---------------------------------------- |
| **Server**           | 服务器应用程序软件的名称和版本           |
| **Content-Type**     | 响应正文的类型（是图片还是二进制字符串） |
| **Content-Length**   | 响应正文长度                             |
| **Content-Charset**  | 响应正文使用的编码                       |
| **Content-Encoding** | 响应正文使用的数据压缩格式               |
| **Content-Language** | 响应正文使用的语言                       |

响应示例：

![img](https://img-blog.csdn.net/20150626150628126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

### Q6：HTTPS是什么？

答：HTTPS是以安全为目标的HTTP通道，它在HTTP中加入SSL层以提高数据传输的安全性。HTTP被用于在Web浏览器和网站服务器之间传递信息，但以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP不适合传输一些敏感信息，比如身份证号码、密码等。为了数据传输的安全，**HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并对浏览器和服务器之间的通信进行数据加密，以保障数据传输的安全性，其端口一般是443。**

### Q7：简述HTTPS的加密流程

答：①发起请求：客户端在通过TCP和服务器建立连接之后（443端口），**发出一个请求证书的消息给服务器**，在该请求消息里**包含自己可实现的算法列表**和其他需要的消息。**②证书返回：**服务端在收到消息后回应客户端并返回证书，在证书中包含**服务器信息、域名、申请证书的公司、公钥、数据加密算法等**。**③证书验证：客户端在收到证书后，判断证书签发机构是否正确，并使用该签发机构的公钥确认签名是否有效**，客户端**还会确认在证书中列出的域名就是它正在连接的域**名。**如果客户端确认证书有效，则生成对称密钥，并使用公钥将对称密钥加密**。④密钥交换：**客户端将加密后的对称密钥发送给服务器，服务器在接收到对称密钥后使用私钥解密**。⑤数据传输：经过上述步骤，客户端和服务器就完成了密钥对的交换，在之后的数据传输过程中，客户端和服务端就可以**基于对称加密**（加密和解密使用相同密钥的加密算法）对数据加密后在网络上传输，保证了网络数据传输的安全性。

```
客户端发起证书请求给服务器
服务器返回证书给客户端(服务器信息,申请认证的公司,公钥,数据加密算法)
客户端收到后验证证书,并用公钥来确认签名是否正确.
认证成功后,客户端生成对称加密密钥,并用公钥加密
服务端接收到后用私密解开这个对称密钥
客户端与服务器用这个对称密钥传输数据
```

 HTTP请求报文字段

```
https://blog.csdn.net/kongmin_123/article/details/82154780?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase
```

HTTP报文首部的结构：由首部字段名和字段值构成的，中间用冒号“:”分割。首部字段格式： 首部字段名:字段值。

例如，在HTTP首部中以Content-Type这个字段来表示报文主体的对象类型：Content-Type:text/html。

上述的Content-Type是首部字段名，text/html是字段值，字段值可以是多个值，例如：Keep-Alive:timeout=15,max=10。

**HTTP首部字段通常有4种类型：通用首部，请求首部，响应首部，实体首部。**

通用首部字段：请求报文和响应报文两方都会使用的首部。

请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。

响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等和实体有关的信息。



### 抓包

**Fiddler**是最强大最好用的Web调试工具之一，它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，**甚至修改输入输出数据**，**Fiddler包含了一个强大的基于时间脚本的子系统，并且能使用.NET语言进行扩展。**对HTTP协议越了解，就能越掌握Fiddler的使用方法。越使用Fiddler，就越能帮助了解HTTP协议。Fiddler无论对开发人员或者测试人员来说，都是非常有用的工具。

Fiddler的工作原理：**Fiddler是以代理web服务器的形式工作的，它使用代理本地地址：127.0.0.1，端口xxxx**，如下图 . 能支持HTTP代理的任意程序的数据包都能被Fiddler嗅探到，**Fiddler的运行机制就是本机上监听Fiddler中设置的端口的HTTP代理。**

抓包过程:

1. 安装fiddler软件, 允许远程计算机连接
2. 设置代理监听端口 , 比如8888端口号 , 重启软件后配置生效
3. 加入要监控手机的数据请求包. 让电脑和手机处于同一个wifi下 ,设置手机的代理->电脑的ip以及Fildder的8888端口. 
4. 如果是https的抓包,则需要安装证书 . 



<img src="C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200914152448206.png" alt="image-20200914152448206" style="zoom:50%;" />



### http与https的区别

超文本传输协议----安全套接字层超文本传输协议

SSL---（Secure Sockets Layer）

**HTTP协议和HTTPS协议区别**

1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安**全性;SSL依靠证书来验证服务器的身份**，并为浏览器和服务器之间的通信加密。

2）HTTPS在TCP三次握手阶段之后，**还需要进行SSL 的handshake，协商加密使用的对称加密密钥**

3）**HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书**

4）HTTP协议端口是80，HTTPS协议端口是443

5) http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议

**HTTPS优点**

HTTPS传输数据过程中使用密钥进行加密，所以安全性更高

HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器

**HTTPS缺点**

HTTPS握手阶段**延时较高**：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加

HTTPS**部署成本高**：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高

**HTTPS连接缓存不如HTTP高效**，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

SL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。



### 数字证书的认证过程

申请者拿到CA的证书并部署在网站服务器端，那浏览器发起握手接收到证书后，如何**确认这个证书就是CA签发**的呢？怎样避免第三方伪造这个证书？答案就是数字签名（digital signature）。**数字签名是证书的防伪标签**，**目前使用最广泛的**SHA-RSA****（SHA****用于哈希算法，RSA****用于非对称加密算法）数字签名的制作和验证过程如下：

1）数字签名的签发。首先是使用哈希函数对待签名内容进行安全哈希，**生成消息摘要**，然后使用CA自己的私钥对消息摘要进行加密。

2）数字签名的校验。使用CA的公钥解密签名，然后使用相同的签名函数对待签名证书内容进行签名并和服务端数字签名里的签名内容进行比较，如果相同就认为校验成功。

![img](https://upload-images.jianshu.io/upload_images/535139-f35b9b088ebaae46.png)



需要注意的是：

1）**数字签名签发和校验使用的密钥对是CA自己的公私密钥，跟证书申请者提交的公钥没有关系。**

2）**数字签名的签发过程跟公钥加密的过程刚好相反，即是用私钥加密，公钥解密。**

3）现在**大的CA都会有证书链，证书链的好处一是安全，保持根CA的私钥离线使用。第二个好处是方便部署和撤销，即如果证书出现问题，只需要撤销相应级别的证书，根证书依然安全。**

4）根CA证书都是自签名，即用自己的公钥和私钥完成了签名的制作和验证。而证书链上的证书签名都是使用上一级证书的密钥对完成签名和验证的。

5）怎样获取根CA和多级CA的密钥对？它们是否可信？当然可信，因为这些厂商跟浏览器和操作系统都有合作，它们的公钥都默认装到了浏览器或者操作系统环境里。

作者：我真的真的是文艺青年
链接：https://www.jianshu.com/p/56fc18937d09



### 加密算法

* **散列函数Hash**

　　**常见的有 MD5、**SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性;
　　在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;

* 对称加密是一把密钥

  这把密钥可以加密明文，也可以解密加密后的密文，常见的对称加密算法有AES、DES、RC4，**目前最常用的是AES。**

* 非对称加密是两把密钥

  分别是公钥和私钥，公钥加密的密文只有相对应的私钥才能解密，私钥加密的内容也只有相对应的公钥才能解密，其中公钥是公开的，私钥是自己保存，不能公开，常见的非对称加密算法**有RSA和ECC（椭圆曲线算法）。**

### *Q10 HTTP1.0/1.1/2.0

https://www.cnblogs.com/heluan/p/8620312.html

其中HTTP协议版本有两种：HTTP1.0/HTTP1.1。HTTP1.0/HTTP1.1的区别：

**http与Http1.1区别**

>1. **缓存处理**，**在HTTP1.0中主要使用header里**的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可**供选择的缓存头来控制缓存策略。**
>2. **带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。**
>3. **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
>4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。**HTTP1.1的请求消息和响应消息都应支持Host头域**，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
>5. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，**在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。**

**SPDY：HTTP1.x的优化**

2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：

>1. **降低延迟**，针对HTTP高延迟的问题，SPDY优雅的采取**了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式**，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。
>2. **请求优先级**（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给**每个request设置优先级，这样重要的请求就会优先得到响应。**比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
>3. **header压缩。**前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的**压缩算法可以减小包的大小和数量。**
>4. **基于HTTPS的加密协议传输**，大大提高了传输数据的可靠性。
>5. **服务端推送**（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接**从缓存中获取到，不用再发请求了。**

**HTTP2.0：SPDY的升级版**

HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：
**HTTP2.0和SPDY的区别：**

1. HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
2. HTTP2.0 消息头的压缩算法采用 **HPACK** http://http2.github.io/http2-spec/compression.html，而非 SPDY 采用的 **DEFLATE** http://zh.wikipedia.org/wiki/DEFLATE

**HTTP2.0和HTTP1.X相比的新特性**

>- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
>- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
>- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
>- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。



### *Q11:http状态码:

状态码告知从服务器端返回的请求的状态，一般由一个三位数组成,分别以整数1～5开头组成。各个响应的类型对应的含义:

HTTP状态码总的分为五类：

1开头：信息状态码

2开头：成功状态码

3开头：重定向状态码

4开头：客户端错误状态码

5开头：服务端错误状态码

**1XX：信息状态码**

| **状态码** | **含义** | **描述**                                     |
| ---------- | -------- | -------------------------------------------- |
| 100        | 继续     | 初始的请求已经接受，请客户端继续发送剩余部分 |
| 101        | 切换协议 | 请求这要求服务器切换协议，服务器已确定切换   |

 **2XX：成功状态码**

| **状态码** | **含义**   | **描述**                                             |
| ---------- | ---------- | ---------------------------------------------------- |
| 200        | 成功       | 服务器已成功处理了请求                               |
| 201        | 已创建     | 请求成功并且服务器创建了新的资源                     |
| 202        | 已接受     | 服务器已接受请求，但尚未处理                         |
| 203        | 非授权信息 | 服务器已成功处理请求，但返回的信息可能来自另一个来源 |
| 204        | 无内容     | 服务器成功处理了请求，但没有返回任何内容             |
| 205        | 重置内容   | 服务器处理成功，用户终端应重置文档视图               |
| 206        | 部分内容   | 服务器成功处理了部分GET请求                          |

**3XX：重定向状态码**

| **状态码** | **含义**     | **描述**                                                     |
| ---------- | ------------ | ------------------------------------------------------------ |
| 300        | 多种选择     | 针对请求，服务器可执行多种操作                               |
| 301        | 永久移动     | 请求的页面已永久跳转到新的url                                |
| 302        | 临时移动     | 服务器目前从不同位置的网页响应请求，但请求仍继续使用原有位置来进行以后的请求 |
| 303        | 查看其他位置 | 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码 |
| 304        | 未修改       | 自从上次请求后，请求的网页未修改过                           |
| 305        | 使用代理     | 请求者只能使用代理访问请求的网页                             |
| 307        | 临时重定向   | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 |

**4XX：客户端错误状态码**

| **状态码** | **含义**       | **描述**                                         |
| ---------- | -------------- | ------------------------------------------------ |
| 400        | 错误请求       | 服务器不理解请求的语法                           |
| 401        | 未授权         | 请求要求用户的身份演验证                         |
| 403        | 禁止           | 服务器拒绝请求                                   |
| 404        | 未找到         | 服务器找不到请求的页面                           |
| 405        | 方法禁用       | 禁用请求中指定的方法                             |
| 406        | 不接受         | 无法使用请求的内容特性响应请求的页面             |
| 407        | 需要代理授权   | 请求需要代理的身份认证                           |
| 408        | 请求超时       | 服务器等候请求时发生超时                         |
| 409        | 冲突           | 服务器在完成请求时发生冲突                       |
| 410        | 已删除         | 客户端请求的资源已经不存在                       |
| 411        | 需要有效长度   | 服务器不接受不含有效长度表头字段的请求           |
| 412        | 未满足前提条件 | 服务器未满足请求者在请求中设置的其中一个前提条件 |
| 413        | 请求实体过大   | 由于请求实体过大，服务器无法处理，因此拒绝请求   |
| 414        | 请求url过长    | 请求的url过长，服务器无法处理                    |
| 415        | 不支持格式     | 服务器无法处理请求中附带媒体格式                 |
| 416        | 范围无效       | 客户端请求的范围无效                             |
| 417        | 未满足期望     | 服务器无法满足请求表头字段要求                   |

**5XX：服务端错误状态码**

| 状态码 | 含义       | 描述                                 |
| ------ | ---------- | ------------------------------------ |
| 500    | 服务器错误 | 服务器内部错误，无法完成请求         |
| 501    | 尚未实施   | 服务器不具备完成请求的功能           |
| 502    | 错误网关   | 服务器作为网关或代理出现错误         |
| 503    | 服务不可用 | 服务器目前无法使用                   |
| 504    | 网关超时   | 网关或代理服务器，未及时获取请求     |
| 505    | 不支持版本 | 服务器不支持请求中使用的HTTP协议版本 |

https://www.cnblogs.com/xflonga/p/9368993.html

400("Bad Request")

这是一个通用的客户端错误状态，当其他4XX响应代码不适用时，就采用400。此响应代码通常用于“服务器收到客户端通过PUT或者POST请求提交的表示，表示的格式正确，但服务器不懂它什么意思”的情况。

401("Unauthorized")

客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书。**客户端提供了错误的证书，或者根本没有提供证书。这里的证书（credential）可以是一个用户名/密码，也可以市一个API key，或者一个认证令牌。**客户端常常通过向一个URI发送请求，并查看收到401响应，以获知应该发送哪种证书，以及证书的格式。如果服务器不想让未授权的用户获知某个资源的存在，那么它可以谎报一个404而不是401。这样做的缺点是：客户端需要事先知道服务器接受哪种认证--这将导致HTTP摘要认证无法工作。

403("Forbidden")

客户端请求的结构正确，但是服务器不想处理它。这跟证书不正确的情况不同--若证书不正确，应该发送响应代码401。**该响应代码常用于一个资源只允许在特定时间段内访问**，**或者允许特定IP地址的用户访问的情况。403暗示了所请求的资源确实存在。**跟401一样，若服务器不想透露此信息，它可以谎报一个404。既然客户端请求的结构正确，那为什么还要把本响应代码放在4XX系列（客户端错误），而不是5XX系列（服务端错误）呢？因为服务器不是根据请求的结构，而是根据请求的其他方面（比如说发出请求的时间）作出的决定的。

404("Not Found")

这也许是最广为人知的HTTP响应代码了。**404表明服务器无法把客户端请求的URI转换为一个资源**。相比之下，410更有用一些。web服务可以通过404响应告诉客户端所请求的URI是空的，然后客户端就可以通过向该URI发送PUT请求来创建一个新资源了。但是404也有可能是用来掩饰403或者401.

405("Method Not Allowd")

**客户端试图使用一个本资源不支持的HTTP方法。例如：一个资源只支持GET方法，但是客户端使用PUT方法访问。**

406("Not Acceptable")

当客户端对表示有太多要求，以至于服务器无法提供满足要求的表示，服务器可以发送这个响应代码。例如：客户端通过Accept头指定媒体类型为application/json+hic，但是服务器只支持application/json。服务器的另一个选择是：忽略客户端挑剔的要求，返回首选表示，并把响应代码设为200。

407("Proxy Authentication Required")

只有HTTP代理会发送这个响应代码。它跟401类似，唯一区别在于：这里不是无权访问web服务，而是无权访问代理。跟401一样，可能是因为客户端没有提供证书，也可能是客户端提供的证书不正确或不充分。

408("Reqeust Timeout")

假如HTTP客户端与服务器建立链接后，却不发送任何请求（或从不发送表明请求结束的空白行），那么服务器最终应该发送一个408响应代码，并关闭此连接。

409("Conflict")

此响应代码表明：你请求的操作会导致服务器的资源处于一种不可能或不一致的状态。例如你试图修改某个用户的用户名，而修改后的用户名与其他存在的用户名冲突了。

410("Gone")

这个响应代码跟404类似，但它提供的有用信息更多一些。这个响应代码用于服务器知道被请求的URI过去曾指向一个资源，但该资源现在不存在了的情况。服务器不知道
 该资源的新URI，服务器要是知道该URI的话，它就发送响应代码301.410和310一样，都有暗示客户端不应该再请求该URI的意思，不同之处在于：410只是指出该资源不存在，但没有给出该资源的新URI。RFC2616建议“为短期的推广服务，以及属于个人但不继续在服务端运行的资源”采用410.

5XX系列响应代码在数量上不如4XX系列多，这不是因为服务器错误的几率小，而是因为没有必要如此详细--对于服务器方面的问题，客户端是无能为力的。

500("Internal Server Error")

这是一个通用的服务器错误响应。对于大多数web框架，如果在执行请求处理代码时遇到了异常，它们就发送此响应代码。

503("Service Unavailable")

此响应代码表明HTTP服务器正常，只是下层web服务服务不能正常工作。最可能的原因是资源不足：服务器突然收到太多请求，以至于无法全部处理。由于此问题多半由客户端反复发送请求造成，因此HTTP服务器可以选择拒绝接受客户端请求而不是接受它，并发送503响应代码。





### *Q12:http请求方式

**HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。**

`OPTIONS`: 返回服务器针对特定资源所支持的HTTP请求方法。

`HEAD`: 与GET请求一致，只不过不会返回响应体。

`GET`: 请求指定的资源。

`POST`: 向指定资源**提交数据进行处理请求，数据包含在请求体中**，可能会导致新资源的创建或已有资源的修改。

`PUT`: 向指定资源位置上传最新内容。

`DELETE`: 请求服务器删除所标识的资源。

![img](https://img-blog.csdn.net/20170831131653293?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTU0MTk0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

作者：策马踏清风
链接：https://www.jianshu.com/p/bec0b7831c82
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### *Q13:http/https区别

> **HTTP协议和HTTPS协议区别**
>
> 1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性
>
> 2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥
>
> 3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书
>
> 4）HTTP协议端口是80，HTTPS协议端口是443
>
> **HTTPS优点**
>
> HTTPS传输数据过程中使用密钥进行加密，所以安全性更高
>
> HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器
>
> **HTTPS缺点**
>
> HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加
>
> HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高

### *Q9:get和post区别

GET和POST的区别：

（1）get是从服务器上获取数据，post是向服务器传送数据。

（2）生成方式不同：

Get：URL输入；超连接；Form表单中method属性为get；Form表单中method为空。

Post只有一种：Form表单中method为Post。

（3）数据传送方式：**Get传递的请求数据按照key-value的方式放在URL后面**，在**网址中可以直接看到**，**使用?分割URL和传输数据**，**传输的参数之间以&相连**，如：login.action?name=user&password=123。所以安全性差。

**POST方法会把请求的参数放到请求头部和空格下面的请求数据字段就是请求正文（请求体）中以&分隔各个字段，请求行不包含参数，URL中不会额外附带参数。所以安全性高。**

（4）发送数据大小的限制：通常**GET请求可以用于获取轻量级的数据，而POST请求的内容数据量比较庞大些。**

Get：**1~2KB。get方法提交数据的大小直接影响到了URL的长度**，但HTTP协议规范中其实是没有对URL限制长度的，限制URL长度的是客户端或服务器的支持的不同所影响。

Post：没有要求。post方式HTTP协议规范中也没有限定，起限制作用的是服务器的处理程序的能力。

（5）提交数据的安全：**POST比GET方式的安全性要高。Get安全性差，Post安全性高。**

**通过GET提交数据，用户名和密码将明文出现在URL上**，如果登录页面有浏览器缓存，或者其他人查看浏览器的历史记录，那么就可以拿到用户的账号和密码了。安全性将会很差。



### NAT是什么?

**NAT（Network Address Translation，网络地址转换）**, 当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。**装有NAT软件的路由器叫做NAT路由器**，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。简**单地说，NAT就是在局域网内部网络中使用内部地址，而当内部节点要与外部网络进行通讯时，就在网关（可以理解为出口，打个比方就像院子的门一 样）处，将 内部地址替换成公用地址，从而在外部公网（internet）上正常使用，NAT可以使多台计算机共享Internet连接，这一功能很好地解决了公共 IP地址紧缺的问题。**

```
https://www.cnblogs.com/vincently/p/4620167.html
```

### ipv4与ipv6的区别,地址结构,分别有多少个地址?怎么算的?

区别: 

网际协议版本（Internet Protocol version，IPv），又称互联网通信协议，是网际协议开发过程中公共协议。而广泛使用的协议有IPv4和IPv6两种，它们的区别是什么呢？下面一起来看一下吧。

**地址空间不同**，IPv4中规定IP地址长度为32，而IPv6中IP地址的长度为128。

**路由表大小不同**，IPv6的路由表相比IPv4的更小。IPv6的地址分配一开始就遵循聚类（Aggregation）的原则，这使得路由器能在路由表中用一条记录（Entry）表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。

**IPv6的组播支持以及对流的支持要强于IPv4。**

**安全性不同，IPv6的安全性更高，在使用IPv6的网络时，用户可对网络层的数据进行加密。**

**协议扩充不同，IPv6允许协议进行扩充而IPv4不允许。**

地址数量:

IPv4中规定IP地址长度为32，即有2^32-1个地址；而IPv6中IP地址的长度为128，即有2^128-1个地址

数据格式:

ipv4:32位--->4个8位 192.168.0.0

IPv6 地址大小为 128 位。首选 IPv6 地址表示法为 x:x:x:x:x:x:x:x，其中每个 x 是地址的 8 个 16 位部分的十六进制值。IPv6 地址范围从 0000:0000:0000:0000:0000:0000:0000:0000 至 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff。

### 子网



### cookie

Cookie是由服务器端生成，发送给User-Agent,**浏览器会将Cookie的key/value保存到某个目录下的文本文件内，**下次请求同一网站时就发送该Cookie给服务器.(**网络服务器用HTTP头向客户端发送cookies**，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies )

cookie**一般该信息记录用户身份。当然cookie也常记录跟踪购物车的商品信息（如数量）、记录用户访问次数等。**

#### 三个阶段:

1. 服务器向客户端发送cookie

   服务器端向客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要像客户端发送的cookie，cookie格式如下：

   Set-Cookie: "name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure"
    其中name=value是必选项，其它都是可选项。Cookie的主要构成如下：

   name:一个唯一确定的cookie名称。通常来讲cookie的名称是不区分大小写的。

   value:存储在cookie中的字符串值。最好为cookie的name和value进行url编码

   domain:cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。**这个值可以包含子域**(如：yq.aliyun.com)，也可以不包含它(如：.aliyun.com，则对于aliyun.com的所有子域都有效).

   path: 表示这个cookie影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径发送cookie。

   **expires:失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)**。如果**不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie**；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。

   max-age: 与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。

   HttpOnly: 告知浏览器不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见。但在http请求张仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。

   secure: 安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置

   需要注意的是，如果给cookie设置一个过去的时间，浏览器会立即删除该cookie；此外domain项必须有两个点，因此不能设置为localhost:

2. 浏览器保存cookie

   按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie , 按存在时间，可分为非持久Cookie和持久Cookie。

3. 再次请求时候浏览器将cookie发送给服务器

#### cookie的分类：

cookie分为会话cookie和持久cookie

* **会话cookie是指在不设定它的生命周期expires时**的状态，前面说了，浏览器的开启到关闭就是一次会话，**当关闭浏览器时，会话cookie就会跟随浏览器而销毁。当关闭一个页面时，不影响会话cookie的销毁。**会话cookie就像我们没有办理积分卡时，单一的买卖过程，离开之后，信息则销毁。

  存储:

  会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的 . 而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。

* **持久cookie则是设定了它的生命周期expires，**此时，**cookie像商品一样，有个保质期，关闭浏览器之后，它不会销毁，直到设定的过期时间。对于持久cookie，可以在同一个浏览器中传递数据，比如，你在打开一个淘宝页面登陆后，你在点开一个商品页面，依然是登录状态，即便你关闭了浏览器，再次开启浏览器，依然会是登录状态。这就是因为cookie自动将数据传送到服务器端，在反馈回来的结果。**持久cookie就像是我们办理了一张积分卡，即便离开，信息一直保留，直到时间到期，信息销毁。

  存储:

  若设置了过期时间，**浏览器就会把cookie保存到硬盘上**，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。**存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。**

#### RFC 2965 HTTP State cookie规范



### Session

#### 什么是session?

session机制采用的是**在服务器端保持状态**的方案(同时我们也看到，由于采用服务器端保持状态的方案**在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的**。而session提供了方便管理全局变量的方式 。)，**而cookie机制则是在客户端保持状态的方案.**

当客户禁用cookie时，这个唯一的值也可能设置为由get来返回给服务器。

**服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存浏览器用户的信息。**

#### 服务器端session机制:

当程序需要**为某个客户端的请求创建一个session时**，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，**这个session id将被在本次响应中返回给客户端保存。**

#### session id的保存方式:

1. **可以采用cookie的方式,**一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。
2. **URL重写**，就是把**session id直接附加在URL路径的后面**。写客户请求的 URL，把 Session ID 添加到 URL 信息中,然后返回修改后的url。
3. **表单隐藏字段。**就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。

https://www.nowcoder.com/search?type=post&query=%E4%B8%8A%E6%B5%B7%E5%86%9C%E5%95%86%E9%93%B6%E8%A1%8C

![image-20200730152855626](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200730152855626.png)



### Cookie与Session区别

```
https://developer.51cto.com/art/201809/583768.htm
```

#### 1.存放的位置不同:

Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存**在集群、数据库、文件中**；

Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

#### 2.cookie与session中存取的内容不同

**Cookie中只能保管ASCII字符串**，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。

**而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等**。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。**能够把Session看做是一个Java容器类。**

#### 3.安全性不同

**Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。**

假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。***是像Google、Baidu那样**将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，**Session里任何隐私都能够有效的保护。**

#### 4.时效性不同

Cookie可以保存信息保存很久。只需要设置Cookie的过期时间属性(expires)为一个很大很大的数字。

由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且**假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。**

#### 5.服务器压力的不同

Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样**并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。**

而**Cookie保管在客户端，不占用服务器资源**。假如**并发阅读的用户十分多，Cookie是很好的选择**。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。

#### 6.跨域支持上的不同

**Cookie支持跨域名访问**(可以访问域名的子域名)，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而**Session则不会支持跨域名访问。Session仅在他所在的域名内有效。**

**仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。**



### Socket编程:

套接字是应用层与传输层协议之间的接口.发送端的应用程序将报文推进套接字.在套接字的另外一层,传输层使得报文传输进入接收进程的套接字,



### 安全套接字



### 输入域名,发生什么

有以下几步:

#### 1.域名解析(DNS域名解析)

根据浏览器输入的url找到域名对应的ip地址.

查找的路径如下:

1.查找浏览器缓存：因为**浏览器一般会缓存DNS记录一段时间**，不同浏览器的时间可能不一样，一般2-30分钟不等，浏览器去查找这些缓存，如果有缓存，直接返回IP，否则下一步。

2.查找系统缓存：浏览器缓存中找不到IP之后，浏览器会进行系统调用（windows中是gethostbyname），查找**本机的hosts文件**，如果找到，直接返回IP，否则下一步。

3.查找路由器缓存：如果1,2步都查询无果，则需要借助网络，路**由器一般都有自己的DNS缓存，将前面的请求发给路由器**.

4.如果还是没有，这个请求就会被发送到ISP（注：Internet Service Provider，互联网服务提供商，就是网络运营商，中国电信中国移动等），ISP也会有相应的ISP DNS服务器，就是本地**DNS服务器**，请求的域名基本上都能在这里找得到。

5.如果还是没有的话， ISP的DNS服务器会将请求发向**根域名服务器**进行搜索。根域名服务器就是面向全球的顶级DNS服务器，共有13台逻辑上的服务器，从A到M命名，真正的实体服务器则有几百台，分布于全球各大洲。

6.如果到了这里还是找不到域名的对应信息，那只能说明一个问题：这个域名本来就不存在，它没有在网上正式注册过。或者域名过期了。

查找域名的过程要这样递归地查询下去，查找完还要一层层的向上返回。例如"mp3.baidu.com"，域名先是解析出这是个.com的域名，然后跑到管理.com域的服务器上进行进一步查询，然后是.baidu，最后是mp3， 所以域名结构为：三级域名.二级域名.一级域名。

所以DNS根据域名查询IP地址的过程为：浏览器缓存 --> 操作系统缓存 --> 路由器缓存-->本地（ISP）域名服务器缓存 --> 根域名服务器。

#### 第三步 ：浏览器与目标服务器建立TCP连接

1. 主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。

2. TCP3次握手连接：浏览器所在的客户机向服务器发出连接请求报文（SYN标志为1）；服务器接收报文后，同意建立连接，向客户机发出确认报文（SYN，ACK标志位均为1）；客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文；此处客户机与服务器之间的TCP连接建立完成，开始通信。

#### 第四步：浏览器通过http协议发送请求

浏览器向主机发起一个HTTP-GET方法报文请求。请求中包含访问的URL，也就是http://www.csdn.com/ ，KeepAlive，长连接，还有User-Agent用户浏览器操作系统信息，编码等。值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。

#### 第五步：某些服务会做永久重定向响应

对于大型网站存在多个主机站点，**负载均衡或者导入流量**，提高SEO排名，往往**不会直接返回请求页面，而是重定向**。返回的状态码就不是200OK，而是301,302以3开头的重定向**码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。**

重定向的作用：重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后**负载到不同的主机上，可以大大提高站点的业务并发处理能力**；重定向也可将多个域名的访问，集中到一个站点；由于baidu.com，www.baidu.com会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。

#### 第六步：浏览器跟踪重定向地址

当浏览器知道了重定向后最终的访问地址之后，重新发送一个http请求，发送内容同上。

#### 第七步：服务器处理请求

服务器接收到获取请求，然后处理并返回一个响应。

#### 第八步：服务器发出一个HTML响应

**返回状态码200 OK，表示服务器可以响应请求，返回报文，由于在报头中Content-type为“text/html”，浏览器以HTML形式呈现，而不是下载文件。**

#### 第九步：释放TCP连接

1. 浏览器所在主机向服务器发出连接释放报文，然后停止发送数据；

2. 服务器接收到释放报文后发出确认报文，然后将服务器上未传送完的数据发送完；

3. 服务器数据传输完毕后，向客户机发送连接释放报文；

4. 客户机接收到报文后，发出确认，然后等待一段时间后，释放TCP连接；

#### 第十步：浏览器显示页面

**在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器接收到返回的数据包，根据浏览器的渲染机制对相应的数据进行渲染。渲染后的数据，进行相应的页面呈现和脚步的交互。**

#### 第十一步：浏览器发送获取嵌入在HTML中的其他内容

比如一些样式文件，图片url，js文件url等，浏览器会通过这些url重新发送请求，请求过程依然是HTML读取类似的过程，查询域名，发送请求，重定向等。不过这些静态文件是可以缓存到浏览器中的，有时访问这些文件不需要通过服务器，直接从缓存中取。某些网站也会使用第三方CDN进行托管这些静态文件。

### 7层网络的作用

![image-20200731151612304](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200731151612304.png)



![img](https://image.fundebug.com/2019-03-21-01.png)







### TCP提供的服务:

面向连接

可靠数据传输

### TCP怎么保证可靠传输的

TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。 为了实现这个需求， 很自然地就会引出**序号（sequence number）** 和 **确认号（acknowledgement number）** 的使用。(序列号是发送方发送的,确认号是接收方发送的.)

发送方在发送数据包（假设大小为 10 byte）时， 同时送上一个序号( 假设为 500)，那么接收方收到这个数据包以后， 就可以回复一个确认号（510 = 500 + 10） 告诉发送方 “我已经收到了你的数据包， 你可以发送下一个数据包， 序号从 510 开始” 。

这样发送方就可以知道哪些数据被接收到，哪些数据没被接收到， 需要重发。

### 拥塞控制

拥塞：即**对资源的需求超过了可用的资源**。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。

拥塞控制：**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。**拥塞控制所要做的都有一个**前提：网络能够承受现有的网络负荷。**拥塞控制是一个**全局性的过程**，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

 流量控制：指点对点通信量**的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。**

拥塞控制代价：**需要获得网络内部流量分布的信息**。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。

**拥塞控制包括四部分：慢启动、拥塞避免、快速重传、快速恢复**

**拥塞窗口大小:**  **发送方**维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。发送方控制拥塞窗口的原则是：只**要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。**

**慢开始算法:**

>慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。
>
>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：
>
>当 cwnd < ssthresh 时，使用上述的慢开始算法。
>
>当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
>
>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。
>
>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的**拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。**

**快重传和快恢复**

>如果**发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃**。这时，**TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。**这是不使用快重传的情况。

![img](https://img-blog.csdn.net/20140509221048265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWVjaGFvZGVjaHVudGlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 流量控制

**利用滑动窗口实现流量控制**

如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓**流量控制**就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上**实现对发送方的流量控制**。

设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，**发送方的发送窗口不能超过接收方给出的接收窗口的数值。**请注意，TCP的窗口单位是字节，不是报文段。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。

### TCP与UDP区别

| 6个          | UDP                                        | TCP                                    |
| :----------- | :----------------------------------------- | -------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流(报文分组)                   |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

- 可靠传输

  对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。

- 提供拥塞控制

  当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞

### DNS攻击



### 如何提高访问外国网站的速度？

国外的网站bai你所经过的路程多.数据经过很多du网关.而且zhi国家与国家之间有个总接dao口总的速度是有限的.建议:用代理服务器,当然,所以你选择代理IP . 

DNS服务器的主要作用就是解析域名,它就像一个翻译官,当我们从浏览器地址栏发送网址时,首先要通过它将网址转换成真实的IP地址才能访问站点。所以作为中间人,DNS服务器的反应速度也会影响上网速度。总是自己手动查找并配置速度较快的DNS服务器,实在麻烦 , **谷歌公共DNS**

服务器的配置是保证网络访问速度的基础，若选择的国外服务器的硬盘、处理器等配置较小就会直接影响到国外服务器的速度。选择国外服务器时选择配置更高的国外服务器，这样就能保障国外服务器的速度。

尽量选择距离国内近的国外机房的服务器，比如美国服务器，目前距离国内最近的是美国西海地区，其中比较优质的机房有美国加州机房。





## **操作系统** **2**

### ***Q1：进程和线程有什么区别？

答：①进程是一个具有独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度的一个独立单位。②线程是一种轻量级的进程，是一个基本的CPU执行单元也是程序执行流的最小单元。线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程不拥有系统资源，只拥有一点运行必备的资源，但可与其他同属一个进程的线程共享进程拥有的全部资源。③引入进程的目的是为了更好地使多道程序并发执行，提高系统资源利用率和吞吐量，增加并发程度。引入线程地目的使为了减小程序在并发执行时的开销，提高系统的并发能力。④堆是线程共享的，栈是线程私有的。

```
1.进程是资源分配的最小单位，线程是CPU调度的最小单位
2.目的不同->进程为了并发,线程为了减小并发的代价
3.占用的资源不同
4.进程与进程,线程与线程之间的影响关系->进程不影响,线程影响
5.线程占用进程的堆,方法区,但每个线程有自己的程序计数器、虚拟机栈和本地方法栈
```

```
https://blog.csdn.net/ThinkWon/article/details/102021274
根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
```



### ***Q2：死锁产生的原因和解决方法？

答：①死锁是多个进程竞争共享资源而造成互相等待的僵局，若无外力作用这些进程都将无法向前推进。②死锁产生的原因是非剥夺资源的竞争和进程的不恰当推进顺序。③预防死锁：破坏互斥条件、破坏不剥夺条件、破坏请求和保持条件、破坏循环等待条件。④避免死锁：安全状态：能找到一个分配资源的序列让所有进程都顺序完成。(在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁);银行家算法：**采用预分配策略检查分配完成时系统是否处于安全状态**。⑤检测死锁：利用死锁定理化简**资源分配图检测死锁的存在。**⑥解除死锁：资源剥夺法：挂起某些死锁进程并抢夺它的资源，以便其他线程继续推进。撤销进程法：强制撤销部分、甚至全部进程并抢夺其资源，以便让其他进程继续推进。进程回退法：让一个或多个进程回退到足以避免死锁的地步。

```
死锁的4个条件:互斥条件-请求保持条件-不可剥夺条件-环路等待条件
（1）互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
（2）请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
（3）不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
（4）环路等待条件：是指进程发生死锁后，必然存在一个进程--资源之间的环形链
```

```
处理死锁的方法:

1.预防死锁-->4个条件
2.避免死锁-->安全状态
3.检测死锁-->资源分配图
4.解除死锁-->资源剥夺,撤销进程,进程回退
```

### ***Q3: 常见LInux指令

* sudo: **以系统管理者的身份执行指令**,经由 sudo 所执行的指令就好像是 root 亲自执行。

* chmod: 修改文件权限

  操作文件或目录的用户，有3种不同类型：文件所有者、群组用户、其他用户。最高位表示文件所有者的权限值，中间位表示群组用户的权限值，最低位则表示其他用户的权限值，所以，chmod 777中，三个数字7分别对应上面三种用户，权限值都为7。

  文件或目录的权限又分为3种：只读、只写、可执行。

  ![image-20200715215702827](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200715215702827.png)

  依照上面的表格，权限组合就是对应权限值求和，如下：

  7 = 4 + 2 + 1      读写运行权限
  5 = 4 + 1             读和运行权限

  4 = 4                   只读权限

  * *chmod 777 文件或目录*

    示例：chmod 777 /etc/squid 运行命令后，squid文件夹（目录）的权限就被修改为777（可读可写可执行）。

  * *chmod 754 filename* 

* mkdir: 创建目录

* chown: linux修改文件或目录的所有者(chown)和用户组

  利用 chown命令 可以将文件的拥有者加以改变。一般来说，这个命令只能由系统管理者(root)使用，一般用户没有权限来改变别人的文件的拥有者，也没有权限可以将自己的文件的拥有者改设为别人。只有系统管理者(root)才有这样的权限。

* chgrp :修改目录或者文件的用户组

```
管理系统:top,df,free,kill
文件处理:mkdir,grep,find,mv,ls,cat,rm,more,less
```



### linux如何执行ls这个命令?

 在CLUI(Command Line User Interface，与GUI对应)模式下，**用户是通过shell与系统交互的**。什么是shell？([提示一](http://zh.wikipedia.org/wiki/Unix_shell)，[提示二](http://software-carpentry.org/v4/shell/index.html))上述两个材料得知shell也是一个程序，它与其他程序最大的不同是：它的目的是执行其他程序，而不是从事计算，绘图，存储等等具体事务。

<img src="https://img-blog.csdn.net/20140329135415640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGp4NTIwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:67%;" />

上图展示了ls命令的执行过程，下面进行简单分析：

- 1、shell不断询问是否有键盘输入，**用户以enter结束键盘输入后**，**shell程序以空格为分隔符，得到"ls"，"-l"，"*.c"，三个字符串。**
- 2、shell发现第三个字符串包含"*"通配符，就会在当前路径(或指定路径)下搜索满足这个通配符的文件。有bar.c和foo.c两个文件，然后展开成{"ls"，"-l"，"bar.c"，"foo.c"}四个字符串，并保存在argv这个二维字符数组中，并赋值argc为4。
- 3、**shell然后搜索PATH这个全局变量保存的路径，寻找一个叫"ls"的命令。如果存在，则fork()一个子进程，调用exec()加载运行ls命令。**ls的main(int argc, string ** argv)函数的参数就是从shell那里得来的。若不存在就会提示用户"command not found"。
- 4、**ls程序执行后，会分析argc和argv**，"-l"表示这是一个选项开关，表明用户想得到文件的详细信息，并把这个开关量保存，以便最后输出的时候选择信息的格式。
- 5、**ls执行完既定的步骤后，退出并返回退出码**，若成功则返回0，否则根据错误的不同返回不同的非零数字。
- 6、**shell在得到成功退出码后，继续等待用户输入。**

如此不断的循环。

### ***进程间通信方式

IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。

① 管道(Pipe)及有名管道(named pipe)

管道通常指无名管道，是 UNIX 系统IPC最古老的形式，是一**种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用**。进程的亲缘关系通常是指父子进程关系。

它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

当一个管道建立时，它会创建两个文件描述符：`fd[0]为读而打开，fd[1]为写而打开`。如下图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019021617091591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0owODA2MjQ=,size_16,color_FFFFFF,t_70)
要关闭管道只需将这两个文件描述符关闭即可。

单个进程中的管道几乎没有任何用处。所以，**通常调用 pipe 的进程接着调用 fork(创建子进程)，这样就创建了父进程与子进程之间的 IPC 通道。**如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190216171147321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0owODA2MjQ=,size_16,color_FFFFFF,t_70)
**若要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）；反之，则可以使数据流从子进程流向父进程。**

**FIFO，也称为命名管道，它是一种文件类型。**

F**IFO可以在无关的进程之间交换数据**，与无名管道不同。FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。

------

② 报文(Message)队列(消息队列)

消息队列是消息的链接表，包括`Posix`消息队列`system V`消息队列，存放在内核中并由消息队列标识符(即队列ID)标识。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。`消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点`。

特点如下：

- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
- **消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。**
- **消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。**

------

③ 共享内存

共享内存就是**映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。**共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

④ 信号(Signal)

信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身。linux除了支持Unix早期信号语义函数signal外，还支持语义符合`Posix.1`标准的信号函数`sigaction`（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。

⑤ 信号量(semaphore)

**信号量是一个计数器**，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,**而用于多线程之间的同步。** **常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。**

   本质上，信号量是一个计数器，它用来记录对某个资源（如共享内存）的存取状况。一般说来，为了获得共享资源，进程需要执行下列操作：

　　（1）测试控制该资源的信号量；

　　（2）若此信号量的值为正，则允许进行使用该资源，进程将进号量减1；

　　（3）若此信号量为0，则该资源目前不可用，进程进入睡眠状态，直至信号量值大于0，进程被唤醒，转入步骤（1）；

　　（4）当进程不再使用一个信号量控制的资源时，信号量值加1，如果此时有进程正在睡眠等待此信号量，则唤醒此进程。

⑥ 套接口(Socket)

更为一般的进程间通信机制，**可用于不同机器之间的进程间通信**。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上,Linux和System V的变种都支持套接字。

**一般来说，linux下的进程包含以下几个关键要素：**

- 有一段可执行程序；
- 有专用的系统堆栈空间；
- 内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才能接受内核的调度；
- 具有独立的存储空间

#### 进程间通信方式的比较

1.管道：速度慢，容量有限，只有父子进程能通讯   

2.FIFO：任何进程间都能通讯，但速度慢   

3.消息队列：容量受到系统限制，**且要注意第一次读的时候，要考虑上一次没有读完数据的问题**   

4.信号量：不能传递复杂消息，只能用来同步   

5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

### 进程同步方式

临界区、互斥对象、事件、信号量四种方式

1、临界区：通过**对多线程的串行化来访问公共资源或一段代码**，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的**线程将被挂起**，并一直等到**进入临界区的线程离开**，**临界区在被释放后，其他线程才可以抢占。**
2、互斥量：采用互斥对象机制。 只有**拥有互斥对象的线程**才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 .互斥量比临界区复杂。**因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。**
3、信号量：**它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目** .信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。

信号量S是一个整数，**S大于等于零时代表可供并发进程使用的资源实体数，但S小于零时则表示正在等待使用共享资源的进程数**。
　　 P操作申请资源：
　　（1）S减1；
　　（2）若S减1后仍大于等于零，则进程继续执行；
　　（3）**若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中**，然后转入进程调度。
　　
　　V操作 释放资源：
　　（1）S加1；
　　（2）若相加结果大于零，则进程继续执行；
　　（3）若相加结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转入进程调度。
4、事 件： **通过通知操作的方式来保持线程的同步**，还可以方便实现对多个线程的优先级比较的操作 .

### 线程同步方式

**线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。**

**① 锁机制**

互斥锁、条件变量、读写锁和自旋锁。

- `互斥锁`确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。
- `读写锁`当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。
- `条件变量`可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
- `自旋锁`上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。

------

**② 信号量机制(Semaphore)**

包括无名线程信号量和命名线程信号量。线程的信号和进程的信号量类似，使用**线程的信号量可以高效地完成基于线程的资源计数**。信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；**只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。**

参考博文：[多线程并发之Semaphore(信号量)使用详解](https://blog.csdn.net/J080624/article/details/85625350)

**③ 信号机制(Signal)**

类似进程间的信号处理。

------

**④ violate全局变量-共享内存**

关于violate可以参考博文：[多线程并发之volatile的底层实现原理](https://blog.csdn.net/J080624/article/details/85318075)

------

**⑤ wait/notify**

阻塞/唤醒，关于这个参考博文：[Thread入门与线程方法详解及多线程安全](https://blog.csdn.net/J080624/article/details/52700413)。

### 线程间是如何传输数据的

java中提供了各种各样的输入／输出流stream，是我们能够很方便的对数据进行操作，其中管道流pipeStream是一种特殊的流，用于在不同线程间直接传送数据。一个线程发送数据到输出管道，另一个线程从输入管道中读取数据。通过使用管道，实现不同线程间的通信，而无需借助于类型临时文件之类的东西。

在java的jdk中提供了4个类来使线程间可以进行通信：
\1. PipedInputStream和PipedOutputStream（用于传输字节流）
\2. PipedReader和PipedWriter（用于传输字符流）

线程间是如何同步与互斥的?

### 管道的调用需要调用fork()与pipe(),谁先调用?

pipe()

### 进程的调度算法

#### 1、先来先服务调度算法

先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中***\*选择一个或多个最先进入该队列的作业，将它们调入内存\****，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是***\*从就绪队列中选择一个最先进入该队列的进程，为之分配处理机\****，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。

#### 2、短作业(进程)优先调度算法

短作业(进程)优先调度算法，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是***\*从就绪队列中选出一个估计运行时间最短的进程\****，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。

#### 3、时间片轮转法

在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，***\*把CPU分配给队首进程\****，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的***\*时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾\****；然后，再把处理机分配给就绪队列中***\*新的队首进程\****，同时也让它***\*执行一个时间片\****。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，***\*系统能在给定的时间内响应所有用户的请求\****。

#### 4、多级反馈队列调度算法

前面介绍的各种用作进程调度的算法都有一定的局限性。如***\*短进程优先的调度算法，仅照顾了短进程而忽略了长进程\****，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则***\*不必事先知道各种进程所需的执行时间\****，而且还可以满足各种类型进程的需要，因而它是目前***\*被公认的一种较好的进程调度算法\****。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述：

1）应***\*设置多个就绪队列\****，并为***\*各个队列赋予不同的优先级\****。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法***\*赋予各个队列中进程执行时间片的大小也各不相同\****，在***\*优先权愈高\****的队列中，为每个进程所规定的***\*执行时间片就愈小\****。例如，第二个队列的时间片要比第一个队列的时间片长一倍，第i+1个队列的时间片要比第i个队列的时间片长一倍。

2）当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则***\*排队等待调度\****。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便***\*将该进程转入第二队列的末尾\****，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列便采取按时间片轮转的方式运行。

3）仅当***\*第一队列空闲时\****，调度程序***\*才调度第二队列中的进程运行\****；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时***\*新进程将抢占正在运行进程的处理\****机，即第i队列中某个正在运行的进程的时间片用完后，由调度程序选择优先权较高的队列中的那一个进程，把处理机分配给它。

#### 5、优先权调度算法

为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常***\*被用于批处理系统中\****，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将***\*从后备队列中选择若干个优先权最高的作业装入内存\****。当用于进程调度时，该算法是把***\*处理机分配给就绪队列中优先权最高的进程\****，这时，又可进一步把该算法分成如下两种。

1) 非抢占式优先权算法

在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便***\*一直执行下去，直至完成\****；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。

2) 抢占式优先权调度算法

在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，***\*只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。\****因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i时，就将其优先权Pi与正在执行的进程j的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi>Pj，则立即停止Pj的执行，做进程切换，使i进程投入执行。显然，这种***\*抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。\****

### 内存管理

### 虚拟内存

### 用户态内核态

### 进程有哪几种状态?各状态时如何切换的?运行态可以切换到就绪态吗?什么情况下会到阻塞态?

一般来说，进程有三个状态，即就绪状态，[运行状态](http://baike.baidu.com/subview/1730379/1730379.htm)，阻塞状态。

​	运行态：进程占用CPU，并在CPU上运行；
​    就绪态：进程已经具备运行条件，但是CPU还没有分配过来；
​    阻塞态：进程因等待某件事发生而暂时不能运行；

下面是3种状态转换图

![img](https://img-blog.csdn.net/20160728195253757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

当然理论上上述三种状态之间转换分为六种情况；

​    运行——>就绪：1，主要是进程占用CPU的时间过长，而系统分配给该进程占用CPU的时间是有限的；2，在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行时，该进程就被迫让出CPU，该进程便由执行状态转变为就绪状态。

​    就绪——>运行：运行的进程的时间片用完，调度就转到**就绪队列**中选择合适的进程分配CPU

   运行——>阻塞：**正在执行的进程因发生某等待事件而无法执行**，则进程由执行状态变为阻塞状态，如发生**了I/O请求**

   阻塞——>就绪:进程所等待的事件已经发生，就进入就绪队列

   **以下两种状态是不可能发生的**：

​    阻塞——>运行：即使给阻塞进程分配CPU，也无法执行，操作系统在进行调度时不会从阻塞队列进行挑选，而是从就绪队列中选取

​    就绪——>阻塞：就绪态根本就没有执行，谈不上进入阻塞态。





## 数据结构与算法

### 数据结构的堆栈

堆:

堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：
 （1）堆中某个节点的值总是不大于或不小于其父节点的值；
 （2）堆总是一棵完全二叉树。

堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。下图图一就是一个最大堆，图二就是一个最小堆。在一个摆放好元素的最小堆中，可以看到，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。

堆常用来实现优先队列，堆的存取是随意的。

<img src="https://upload-images.jianshu.io/upload_images/4037795-d609d607f67d4c0a.jpg?imageMogr2/auto-orient/strip|imageView2/2" alt="img" style="zoom:67%;" />

栈:

栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。

而且栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。

堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。

##### 注意：其实堆栈本身就是栈，只是换了个抽象的名字。

栈的应用——递归

队列:

队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。



### 内存的堆栈

https://www.jianshu.com/p/5f148c3e4f7d

申请方式的不同:

内存中的堆和栈第一个区别就是申请方式的不同：栈是系统自动分配空间的，而堆则是程序员根据需要自己申请的空间。由于栈上的空间是自动分配自动回收的，所以**栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉**，不可以再访问。而堆上的数据只要程序员**不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。**

申请效率的比较：**栈由系统自动分配，速度较快。但程序员是无法控制的。堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便**。

申请大小的限制：

**栈：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。**这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），**如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。**

**堆：堆是向高地址扩展的数据结构，是不连续的内存区域。**这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，**堆获得的空间比较灵活，也比较大**。



### dfs与bfs的区别

**dfs(深度优先搜索)就是暴力把所有的路径都搜索出来，它运用了回溯，保存这次的位置，深入搜索，都搜索完了便回溯回来，搜下一个位置，直到把所有最深位置都搜一遍，要注意的一点是，搜索的时候有记录走过的位置，标记完后可能要改回来；回溯法是一种搜索法，按条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法；**

**bfs(宽度/广度优先搜索)，这个一直理解了思想，不会用，后面才会的，思想，从某点开始，走四面可以走的路，然后在从这些路，在找可以走的路，直到最先找到符合条件的，这个运用需要用到队列(queue)，需要稍微掌握这个才能用bfs。**



其实有时候两个都可以用，不过需要其他的东西来记录什么的，各自有各自的优势

**bfs是用来搜索最短径路的解法是比较合适的**

比如求最少步数的解，最少交换次数的解，最快走出迷宫等等，**因为bfs搜索过程中遇到的第一个解一定是离最初位置最近的，所以遇到第一个解，一定就是最优解，此时搜索算法可以终止**
 而如果用dfs，会搜一些其他的位置，需要花相对比较多的时间，需要搜很多次，然后如果找到还不一定是最优解，**还要记录这次找的位置，与之后找到的答案进行比较**，看看谁才是最优解，这样就比较麻烦 ; 

**bfs是浪费空间节省时间，dfs是浪费时间节省空间。**

因为dfs要走很多的路径，可能都是没用的，（做有些题目的时候要进行剪枝，就是确定不符合条件的就可以结束，以免浪费时间，否则有些题目会TLE）；
 而bfs可以走的点要存起来，需要队列，因此需要空间来储存，便是浪费了空间，假设有十层，各个结点有2个子节点，那么储存到第10层就要存 2^10-1 个数据，而dfs只需要存10个数据，但是找到答案的速度相对快一点。