# 删数

有一个数组a[N]顺序存放0~N-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0->1->2(删除)->3->4->5(删除)->6->7->0(删除),如此循环直到最后一个数被删除。

##### **输入描述:**

```
每组数据为一行一个整数n(小于等于1000)，为数组成员数,如果大于1000，则对a[999]进行计算。
```

##### **输出描述:**

```
一行输出最后一个被删掉的数的原始下标位置。
```

##### **输入例子1:**

```
8
```

##### **输出例子1:**

```
6
```

```c++
#include <iostream>
#include<queue>
using namespace std;
int main()
{
	int N;
	while (cin >> N) {
		queue<int> q;
		for (int i = 0; i < N; ++i)
			q.push(i);
		int count = 0;
		while (q.size() != 1)
		{
			if (count != 2)
			{
				int a = q.front();
				q.push(a);
				q.pop();
				count++;
			}
			if (count == 2) {
				q.pop();
				count = 0;
			}
		}
		cout << q.front() << endl;
	}
	return 0;
}
```

# 字符集合

输入一个字符串，求出该字符串包含的字符集合

##### **输入描述:**

```
每组数据输入一个字符串，字符串最大长度为100，且只包含字母，不可能为空串，区分大小写。
```

##### **输出描述:**

```
每组数据一行，按字符串原有的字符顺序，输出字符集合，即重复出现并靠后的字母不输出。
```

##### **输入例子1:**

```
abcqweracb
```

##### **输出例子1:**

```
abcqwer
```

```c++
#include<iostream>
#include<string>
#include<set>
using namespace std;

int main() {
	string s;
	while (cin >> s) {
		set<char> se;
		string out="";
		for (size_t i = 0; i < s.size(); ++i)
		{
			if (se.find(s[i]) == se.end())
				out = out + s[i];
			se.insert(s[i]);	
		}
		cout << out << endl;
	}
}
```

  # 汽水瓶

有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？  

##### **输入描述:**

```
输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1<=n<=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。
```

##### **输出描述:**

```
对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。
```

##### **输入例子1:**

```
3
10
81
0
```

##### **输出例子1:**

```
1
5
40
```

```c++
#include<iostream>
using namespace std;

int main() {
	int N;
	while (cin >> N && N != 0) {
		int shui = 0;
		while (N != 1) {
			int shang = N / 3;
			int yu = N % 3;
			shui = shui + shang;
			N = shang + yu;
			if (N == 2)
				N = N + 1;
		}
		cout << shui << endl;
	}
	return 0;
}
```

# 明明的随机数

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 
 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 

  样例输入解释： 

  样例有两组测试 

  第一组是3个数字，分别是：2，2，1。 

  第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。

##### **输入描述:**

```
输入多行，先输入随机整数的个数，再输入相应个数的整数
```

##### **输出描述:**

```
返回多行，处理后的结果
```

##### **输入例子1:**

```
3
2
2
1
11
10
20
40
32
67
40
20
89
300
400
15
```

##### **输出例子1:**

```
1
2
10
15
20
32
40
67
89
300
400
```

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	int N,n;
	while (cin >> N) {
		vector<int> vec;
		for (int i = 0; i < N; ++i) {
			cin >> n;
			vec.push_back(n);
		}
		sort(vec.begin(), vec.end());
		vector<int>::iterator it = unique(vec.begin(), vec.end());
		for (vector<int>::iterator i = vec.begin(); i != it; ++i)
			cout << *i << endl;
	}
	return 0;
}
```

# 进制转换

写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）  

##### **输入描述:**

```
输入一个十六进制的数值字符串。
```

##### **输出描述:**

```
输出该数值的十进制字符串。
```

##### **输入例子1:**

```
0xA
```

##### **输出例子1:**

```
10
```

```c++
#include<iostream>
#include<string>
#include<map>
#include<cmath>
using namespace std;

int main() {
	string s;
	map<char, int> m{ {'0',0},{'1',1},{'2',2},{'3',3},{'4',4},{'5',5},{'6',6},{'7',7},{'8',8},{'9',9},{'A',10},{'B',11},{'C',12},{'D',13},{'E',14},{'F',15}};
	while (getline(cin, s)) {
		int out = 0;
		size_t t = s.size()-3;
		for (size_t i = 2; i < s.size(); ++i)
		{
			out = out + m[s[i]] * pow(16,t);
			t = t - 1;
		}
		cout << out << endl;
	}
}
```

# 归并排序

```c++
#include<iostream>
#include<vector>
using namespace std;

void merge(int arr[], int left, int mid, int right)
{
	std::vector<int> *result = new std::vector<int>();
	int l = left;
	int m = mid;
	while (l <= mid - 1 && m <= right)
	{
		if (arr[l] <= arr[m]) {
			result->push_back(arr[l++]);
		}
		else {
			result->push_back(arr[m++]);
		}
	}
	while (l <= mid - 1) {
		result->push_back(arr[l++]);
	}
	while (m <= right) {
		result->push_back(arr[m++]);
	}
	for (auto item : *result)
	{
		arr[left++] = item;
	}
}

void mergeSort(int arr[], int left, int right)
{
	if (right - left < 2)
	{
		if (arr[left] > arr[right])
		{
			std::swap(arr[left], arr[right]);
		}
		return;
	}
	int m = (right + left) / 2;
	mergeSort(arr, left, m);
	mergeSort(arr, m + 1, right);
	merge(arr, left, m + 1, right);
}

int main()
{
	int test[10];
	for (int i = 0; i < 10; ++i)
	{
		test[i] = std::rand() % 100;
	}
	std::cout << "排序前" << std::endl;
	for (int i = 0; i < 10; ++i)
	{
		std::cout << test[i] << " ";
	}
	std::cout << std::endl;
	mergeSort(test, 0, 9);
	std::cout << "排序后" << std::endl;
	for (int i = 0; i < 10; ++i)
	{
		std::cout << test[i] << " ";
	}
	std::cout << std::endl;
	return 0;
}

```

